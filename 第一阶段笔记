day01
三大操作系统：
UNIX
	AIX(IBM)
	Solaris(SUN/Oracle)
	MAC os X(Apple)
	Ios (Apple)
Linux(当前教学)
	Ubuntu :
			 用户名:tarena 密码：tarena
	Redhat
	Cenros
	Android(安卓)
Windows
	win10 ,win7 ,winxp ,win98 ,win95 ,win3.2
	计算机的组成：
		硬件
			处理器(cpu)
			运行内存(Ram)
			主板（总线设备）
			外部存储设备（硬盘，u盘）
			输入输出设备
		　软件
			　操作系统软件     内核模式
			　标准库软件　　　    用户模式
			　应用软件         用户模式
Vmware
	开启BIOS里的虚拟机支持功能:
		virtual Tech [disable/Enable]
	打开终端和退出终端：
	１，点击图标
	２，搜索命令：gnome-terminal 或"终端"
	退出：
	 exit        
Linux命令的格式：
命令名　[选项]　[参数]
列如:
 $ pwd
 $ ls -l
 $ cd /
 $ ls /usr/bin -l
说明:
	有些命令没有选项和参数

目录树和根
	 根：root
	 Linux: /
	 windows :
		 C:
		 D:
		 列如：
			/usr/bin/pyehon3(Linux下的文件)
		 C:\Windows\system32\cal.exe(windows下的文件)

路径：
　路径是用来记录一个文件或文件夹的字符串

路径分为两种：
	绝对路径　和　相对路径

绝对路径　：
以"/"字符开头的路径为绝对路径
绝对路径通常能标识唯一的文件和文件夹

相对路径：
	不以"/"开头的路径为相对路径
	开始符号：
		　以文件名/文件夹名开头
		　.开头当前文件夹
		　..开头(上一级文件夹)
		　～用户主目录(家目录)
示例：

	cd /usr/bin/    #进入/usr/bin目录
	ls -l .python3　＃查看当前python3文件的信息
	cd ..
	ls -l
pwd 命令:
	作用：
		用于显示当前操作的路径位置（当前工作路径）
cd 命令：
	作用：
		改变当前工作路径（进入某个目录）
	格式：
		cd [目录名]
	示例：
		cd/home/tarena
		cd /  #进入根目录
		cd　　　　#默认进入用户主目录
		cd ..　＃进入上一层目录
		cd -　　　＃进入到进入此目录前的那个目录
ls 命令：
	作用：
		用来显示文件或文件夹的信息
	格式：
		ls [选项][文件夹名/文件名]
	常用选项：
		-l 列表显示文件的详细信息
		-a 显示全部文件/文件夹信息(显示.开头的文件)
	示例：



mkdir 命令：
	作用：
		创建一个或多个文件夹（也叫目录）
	格式：
		mkdir 文件夹１　文件夹２．...
	示例：
		mkdir a s d f
	常用选项：
	　-p 如果中间文件夹不存在，则逐级创建所有文件夹
	示例：
		mkdir -p a/s/d/f
rmdir 命令：
	删除一个或多个文件夹（文件夹内必须没有文件）
　格式：
	同　mkdir
 选项：
	　-p 如果中间的文件夹也为空，则逐级删除中间的空文件件夹
 格式：
	rmdir a d f s
	rmdir 


 tree 命令
	作用:
 显示目录树

 安装方法：
	　$ sudo apt install tree{回车}
	　输入密码：tarena
 示例:
	 $ tree # 等同于 tree .
	 $ tree /home/tarena/aid1803
touch命令：
　作用：
	１．如果文件不存在，则创建一个空文件
	２．如果文件或目录存在，则用系统时间更新他的修改时间
例：
　touch s.txt

rm 命令
　作用：
	删除文件或文件夹
格式
	rm [选项]
常用选项：
	-r 递归删除文件夹内部的全部文件或文件夹
	-i 删除当前给出提示(y表示yes,n表示no)
	-f 强势删除，不给任何提示

练习:
１．进入到/usr/bin 目录下，查看是否有python3和ls这两个文件
	cd /usr/bin
	ls -l python3
	ls -l ls
２．再进入到/etc目录下，查看passwd这个文件的大小是多少字节？
	cd /etc
	ls -l passwd
３．回到用户目录下
	cd ~
４．查看当前目录下都有那些隐藏文件
	ls -a
５．创建以文件夹"aid1803"
	mkdir aid1803
6.再aid1803下创建一个文件夹linux
	mkdir -p aid1803/linux
7.在aid1803/linux下创建三个文件夹：
	(day01 day02 day03)
	cd aid1803/linux
	touch day01 day02 day03
8.在day01下创建day01.txt,在day02下创建day02.txt,在day03下创建day03.txt
	touch day01/day01.txt
	touch day02/day02.txt
	touch day03/day03.txt
9删除day03文件夹及其中的文件
	rm -r day03



day02笔记
help 帮助选项
	选项:
		--help
	作用：
	查看一些命令有哪些选项，这些选项都是干什么
	例：
	　ls --help　
		mkdir --help
man 命令帮助
　格式
	man linux/UNIX命令名
作用：查看命令所对应的帮助文档（手册）
例：
	man ls
	man mkdir
说明：
	退出键：q

Tab 键
作用：
	自动补全命令或文件路径

history 命令
	作用：
	把以前键入的历史命令都列出来
注：在终端$提示符下。用上下键翻出历史命令

通配符

* 代表0个１个或多个任意字符
? 代表一个任意字符
示例：
有如下文件：
	a ab ac abc aabb bc cd
a* 代表所有以a开头的文件
a*b　代表所有以a开头，以b结尾的文件
a?　　代表 ab ac
?c  代表　ac bc
....
练习:
１.　创建文件夹myfiles
2. 在myfiles文件夹内创建文件：
　a,mp3 ab.txt ac.mp3 abc.txt aabb.mp3
bc.txt cd.mp3
3.　列出所有以.mp3结尾的文件
４.删除.之前只有一个字符的文件
５.列出含有c这个字符串的文件
６.删除myfilfefs文件内所有的mp3文件
mkdir myfiles

touch 　a,mp3 ab.txt ac.mp3 abc.txt aabb.mp3
bc.txt cd.mp3

ls *.mp3

rm ?.*

ls *c*

rm *.mp3


文本编辑器:
	sublime text 3
	 vi
	 notepad++
sublime text 文本编辑器
启动命令：
	subl[回车]
	subl 文件名或文件夹名[回车]
sublime 的快捷操作：
１．打开和隐藏　侧边栏
view ->Side Bar —> show/Hide Side Bar
快捷键
	Ctrl +k b
注：只有打开文件夹时才有侧边栏
２．字体的放大缩小：
	ctrl+ 鼠标滑轮
快捷键
	ctrl+ "+"/"-"
3.创建和取消多个光标
ctrl +鼠标左键点击　　　创建多个光标
ESC 键取消多个光标
４．批量多选相同的选择块
	ctrl+d
５．注释：ctrl + /
6. 剪切　ctrl + x
	 复制　ctrl + c
	 粘贴　ctrl + v
7. 交替换行
	 ctrl + shift +上下键
8. 撤销undo/重做redo
	 ctrl + z
	 ctrl + y
9. 保存文件（重载）
	 ctrl + s
cat 命令
 作用：将文本文件的内容作为标准输出显示
 格式：
	cat 文件名1 文件名2 
 示例：
	cat day02.txt
cp 命令
	作用：
		复制文件或文件夹
 格式：
	 cp[选项]　源文件或文件夹　目标文件或文件夹
 常用选项：
	-a 复制文件夹及其内部的内容

mv 命令
作用：
文件搬移或更名
格式：
mv 源文件或文件夹　目标文件或文件夹

find 命令
作用：
根据文件名称等信息查找指定文件
常用格式：
find 路径("/")　-name "文件名"
例：
find / -name "day01.txt"
find ~ -name "day01.txt"
find /home/tarena/aid1803 -name "*.txt"

grep 命令：
　作用：
	查找文件中相应的内容及文本信息
格式：
grep "内容"[选项]　文件名或文件夹
常用选项：
-n 显示行号
　-r 递归搜索文件夹内的文件
grep "ctrl" *  #查找Ｃｔｒｌ在哪

终止程序：
　ctrl + c
练习：
2.
查找gzip 和tar 这两个文件在什么位置
查找/etc 文件夹下的那些文件里含有"tarena"这个内容
将　/etc/group文件复制到　当前文件夹
将/etc/passwd 文件复制到当前文件夹并改名为："系统账户管理配置文件.txt"
2.
find / -name "gzip"
find / -name "tar"
grep "tarena" -nr /etc
cp /etc/group .
cp /etc/passwd 系统账户管理配置文件.txt

gzip 命令
作用：
	用zip无损数据压缩算法对文件进行压缩，生成压缩后文件
格式：
	gzip 文件名
示例：
gzip testgzip.txt
ls -l testgzip.txt.gz
注　.gz 文件是用gzip压缩后的文件
gunzip 命令
作用：用于解压zip(.gz结尾的)压缩包
格式：
gunzip 文件名（.gz文件）
例：gunzip testgzip.txt.gz

tar 命令：
作用：　对文件或文件夹进行打包和解包的操作
格式：　tar [选项]　文件名或路径
常用选项：
-c     　　　　　创建包
-x     　　　　　解包
-f 文件名　　　　操作的文件名
-v   　　　　　　　显示操作的文件细节
-z   　　　　　　　用gzip/gunzip 对包进行压缩或解包
注：tar打包的文件后缀是　.tar
例：1).tar -cvf day02.tar day02           #将day02打包为　day02.tar文件但不压缩
2).tar -xvf day02.tar    
 # 解包day02.tar
3).tar -czvf day02.tar.gz day02  #将打包和压缩的工作一起进行
4).tar -xzvf day02.tar.gz
 # 解压缩一个.tar.gz 结尾的tar包

文件的权限管理及命令

 ls -l    #查看文件权限

文件的权限类型：
 r 读权限　　# 具有读取文件内容的权限
 w 写权限　　# 具有新增，修改，删除文件内容的权限
　x 执行权限　# 具有执行权限
　- 无权限
权限的分组：
用户权限(user) 组权限(group) 其他用户(other)
 rwx            rwx          rwx
最高权限：　rwxrwxrwx
最低权限： ---------

chmod 命令
作用：　用来修改文件权限
格式：　chmod  权限 文件名/文件夹名
权限：
	u  用户(user)[属主]
	g  同组用户(group)[属组]
	o  其他用户(other)
	a  所有用户
	+  加权限
	-  取出权限
示例：
chmod u+r   a.txt
chmod o-rwx a.txt

输出重定向分两种:
 1.标准输出
 2.标准错误输出
标准输出重定项
>  将一个命令的标准输出重定向到指定文件
>>　将一个命令的标准输出追加到到指定文件末尾
例：
 find /etc -name "group" > output.txt
 find /etc -name "group" >> output.txt

 标准错误输出重定向：
 2>  将一个命令的错误信息重定向到指定文件 
 2>>　将一个命令的错误信息追加到到指定文件末尾

重定向所有输出：
 &>
 &>>
作用：将所有输出重定向到指定文件中
	 将所有输出重定向追加到指定文件中

/dev/null 文件：
	写入此文件的内容全部被丢掉 
例：　find / -name "gzip" 2> /dev/null

clear 命令：
作用：　清屏
快捷键：　ctrl + l
练习：
3.
编写一个shell脚本，要求：
１．在/home/tarena/aid1709下创建文件夹：mydir
２．在/etc下查找passwd文件，把屏幕所有输出重定向到：mydir/result.txt
３．在result.txt文件末尾添加字符串:"此为passwd文件查找屏幕所有输出"
４．将result.txt打包压缩为result.tar.gz
５．再将result.tar.gz解压到/home/tarena/目录下
3.
subl fu.sh
#! /bin/shell
mkdir -p aid1708/myd
cd aid1708/myd
find /etc -name "passwd" &> resu.txt
echo "此为passwd文件查找屏幕所有输出"　>> resu.txt
tar -czvf resu.tar.gz resu.txt
tar -xzvf resu.tar.gz -C /home/tarena/
chmod a+x fu.sh
./fu.sh

 《python基础》
　
python的诞生：
	创建人　：　Guido van Rossum(荷兰人)
	时间：　1989年圣诞节期间

计算机语言发展：
１．二进制　机器指令
２．汇编语言：
	ADD R0 R1
	ST  R2
3.编译型语言：
	C / C++ /PASCAL / go
4.解释执行语言：
	python / java / basic / C# / Swift
python的应用领域：
　系统自动化运维
　网络编程(搜索引擎，爬虫，服务器编程等)
　科学计算
 人工智能，机器人
 web开发
 云计算
 大数据及数据库编程
 教育
 游戏
 ...

python的优点：
	面向对象(java, c++, python, C#, Swift)
	免费
	可移植
	可混合编程(C/C++/Java/.net)
	简单易学易用
	开发效率高
	应用领域广泛
	开源
缺点：
	与C/C++相比，执行效率不够快
	不能封闭源代码
	不能写操作系统内核和驱动程序

python的官网：
	www.python.org

python的版本：
	v2.7(2020年结束维护)
	v3.5(当前教学)
	v3.8(最新)
	　
python的解释执行器类型：
	/usr/bin/python3
	Cpython　　    (C语言开发)  
	Jython       (Java语言开发)
	Ironpython   (.net开发) 

第一个python程序：
	编写hello.py
	写入：
	print("hello world!") #左侧不要留空格
执行python3程序：
	１．用python3解释执行
		$ /usr/bin/python3 hello.py
	2.直接执行：
	１）在hello.py的第一行加入：
	#! /usr/bin/python3
	2)添加执行权限
	$ chmod a+x hello.py
	3)执行：
	　$ ./hello.py
练习：
4.
写一个tesr.py，此文本写入python三条打印语句，
打印如下：
		这是我的python第一条语句
		我现在开始学python了
		这是最后一条语句
	要求用以下方式执行：
	　$python3
	 $./tesr.py
把test.py的内容输出重定向到myprint.txt
4.
subl  tesr.py

#! usr/bin/python3
 print("这是我的python第一条语句")
 print("我都现在开始学python")
 print("这是最后一条语句")

python3 tesr.py 
chmod a+x tesr.py
./tesr.py
cat tesr.py > myprint.txt


day03 
	常用的程序文件后缀：
	.py  　　python3文件
	.c   　　C语言文件
	.cpp 　　C++语言文件
	.java 　java语言文件


python解释执行器：
	python  (python2的解释执行器)
	python3　(python3的解释执行器)
python解释执行器的交互模式：
	$  python3 [回车]　# 进入交互模式

	退出交互模式：
	>>> exit() [回车]
	>>> quit() [回车]
	ctrl + d
python 的注释：
	python 的注释是以#开头，直至行尾
	作用：让注释内容不参加注释执行
python程序的组成：
	程序有模块组成
	模块由语句，函数，类等组成
	语句包含表达式
	表达式建立并处理数据对象且能返回数据对象的引用关系

python　的核心数据类型：
	数字：(整型，浮点数，复数，布尔型(bool))
	字符串　str
	列表　　　list
	字典
	元组
	集合
	......

	数字类型：
　１）整型数　int
	　　整型数是不带有小数部分的数字。包括自然数，0及负数自然数
	　　如：　　-2  100  0
	　　整数字面值的表达方式：
		十进制方式表示：
		　　-10
		 　　0
		　　99999999999999
	　　　八进制的表示方式(0o开头，后跟0~7)
		　　0o177  (127)
		　　0o11   (9)
	　　　二进制表示方式(0b开头，后跟0~1)
		　　0b1001
	　　　十六进制的表示方式：(0x开头, 后跟A~F, a~f)
		　　0x11  (17)
		　　0xFF  (255)
		　　0x1234ABCD
２）	浮点型数　float
	　　浮点数时代有小数部分的数字(小数部分也可以是0)
	　　浮点数的两种表示方式：
		小数表示：
			　3.14
			 3.1
			 3.0
			 3.
			 0.14
			 .14
		科学计数法：
		　格式：
			 小数 e/E(正负号)　　指数
				 6.18E-1
				 2.9979e8
３）　复数　complex
	　　分为两部分：
	　　实部(real)
	　　虚部(image)
	　　注：虚部必须是以j或J结尾的数
	复数字面值：
	　　1j
	　　(2j)
	　　1+1j
	(-100+100j)
４）　布尔类型：　bool
	　　用来真假两种状态的类型：
		True 表示真(条件满足或成立)
		False 表示假(条件不满足或不成立)
	　　说明：
		True 　值为１　
		False　值为0
	空值　None
	　　None 是一个表示不存在的的特殊对象
	　　作用：
		1)用来语法占位
		2)变量解除绑定

表达式和运算符
	表达式　　expression
	 由数字或数字和运算符组成
	作用：通常让计算机做一些事情并返回结果
	示例：
	　1+2
	　1+2*3
运算符：
算术运算符：
 +    加法
 -    减法
 *    乘法
 /    除法
 //   地板除floordiv(python2.3之后)
 %    求余
 **   幂运算

python 的除法不会丢掉小数部分
	1/3     #　0.333333
	6/2    # 3.0
地板除：
	7/3        # 2.3333
	7//3       # 2
	3.25//1.5  # 2
求余：
	7%3        # 1
	3.25%1.5   # 0.25 
幂运算:
	格式：x**y
	意为：x的y次方
	示例：
		5**2         # 25
		3.0**2.0     # 9.0
		5.6**1.418   # ???  
练习：
1.
一个学生毕业后月薪10000元，每年涨20%
算十年后他的月薪是多少？
1.
10000*(1+0.2)**10


运算符的优先级:
	**           (最高)
	*  /  //  %  (中　　)[相同优先级时，从左到右计算]
	+  -         (相对较低)

括号分组子表达式:
	用() 可以将表达式分组，()内部的表达式先进行计算
混合类型自动升级：
	1+5.14   返回类型为浮点型　　# 6.14

基础输出函数：
	 print
格式：　print(要打印的东西)
示例：
	print("hello")
	print(1+2*3)
	print(1+2,3+4,100)　　#多个数据打印时用逗号分隔开

练习：
2.
写程序在终端输出图形：
		 ##########
		 #        #
		 #        #
		 ##########
已知矩形的长边为６cm,短边为4cm 求矩形的边长和面积并用print函数打印在终端上
2.
   　　print("#########")
	 print("#       #")
	 print("#       #")
	 print("#########")
   　　r=6
	 t=4
	 s=r*t
	 l=(r+t)*2
	 print("面积为:",s,"周长为:",l)


变量：
　定义：变量是关联一个对象的标识符(符号)
　
　作用：
		用来绑定一个数据对象，以便于以后重复使用
变量的命名方法：
	１．变量名必须为字母或下划线开头，后跟字母，下划线或数字
	２．不能使用python的关键字(保留字)
说明：
	python 变量名区分大小写

合法的变量名：
	a  a1  b  bbb  _aaa  __ABCD  var get_value   AbCd
不合法的变量名：
	1a  123  $ABC  +a  -b  ###  @ABC　　a1&  a#b
python3的关键字：
	True , False , None , is , del , if , felif , else , pass , not  ...(共计33个)


赋值语句：　statement
	符号：　　=
	
	语法：　　变量名=　表达式
	或　　变量名1  = 变量名2  = 表达式
	或　　变量名1  = 变量名2，... =　序列
作用：　用于将一个变量绑定，（或关联）在一个对象上
说明：
１.当变量不存在时，创建该变量，并绑定这个对象
２.当变量存在时，改变这个变量的绑定关系
３.一个变量只能绑定一个对象
４.两个变量可以同时绑定同一个对象

python中的自动化内存管理
	a=1000
	b=2000
	a=a+b
	c=a
	a=b=c=10000+20000 　#　三个变量同时绑定同一个对象
	　a=1
	 b=2
	 c=3
 #以上三行可以写为：
	a,b,c = 1,2,3
	a,b,c = [1,2,3]
	a,b,c = (1,2,3)
python 关联/绑定/引用的含义
	关联/绑定/引用都是指变量和一个对象的关联关系
	python中变量没有类型

练习：
3.
知道一个圆的半径r为3cm
  计算这个圆的周长
  计算面积是多少
将这个圆的半径改为10
  再次计算
3.
	r=float(input("请输入半径:"))
	e=3.14
	s=e*r**2
	l=2*e*r
	print("圆的周长:",l,"圆的面积:",s)

练习：
	变量交换的练习：
已知有两个变量：
	a=10000
	b=20000
	如何在不创建新的对象的情况下，让a和b交换绑定的对象？
		方法一
		t=a  #创建新的变量用于用于临时绑定变量
		a=b
		b=t
		print(a)
		print(b)
		方法二
		a,b = b,a  # 用序列赋值也可以实现交换
		print(a)
		print(b)

is /is not 运算符：
　is 的作用：
		判断两个对象是否是同一个对象，如果是同一个对象，返回True,否则返回False
 is not  的作用与 is 相反
语法：
	x is y
	x is not y

小整数对象池：
　Cpython中，整数　-5　至　256　永远存在于内存中不会释放，并可以重复使用

id 函数：
作用：
	返回一个对象在内存中的地址
用法：
	id(x)  
 1byte(字节) = 8bit(位)
 1M million 1,000,000
 1K kilo    1,000
 1G giga    1,000,000,000


del 语句
	作用：
	　用于删除变量，同时解除与对象的关联关系，如果可能，则释放对象
	语法：
	　del 变量名
	del a,b,c 删除多个变量

在交互模式下，查看当前作用域内变量的方法：
	　>>> help("__main__")
	 退出键：q 
自动化内存管理和引用计数
	每个对象都会记录有几个变量引用自身，当引用的数量为0时，则此对象将被销毁

符合赋值算术运算符：
　y += x 等同于 y= y + x
 y -= x 等同于 y= y - x
 y *= x 等同于 y= y * x
 y /= x 等同于 y= y / x
 y //= x 等同于 y= y // x
 y %= x 等同于 y= y % x
 y **= x 等同于 y= y ** x
 

练习：
	１．在终端打印图形：
	*
　 ***
 *******
*********
2.中国古代的秤是16两一斤，请问古代的216两是古代的几斤几两？　写程序打印出结果
3.　从凌晨0:0:0: 计时，到现在已经过了63320秒，请问现在是几时，几分，几秒，写程序打印出来
(提示：用地板除和求余可以解决上述问题)  
1.  print("   *   ")
	print("  ***  ")
	print(" ***** ")
	print("*******")

2.  t=216//16
	y=216%16
	print("216两是古代的:",t,"斤",y,"两")
3.  e=63320//60
	p=e//60
	r=e%60
	u=63320%60
	print("63320秒为:"p,"时",r,"分",u,"秒")




练习：
１．python变量的命名规则
２．给变量a赋值为1，变量b赋值为2,然后删除变量a,b
３.请编写hello.py 程序输出"hello world!"
并用两种方式执行此程序
	#! /usr/bin/python3
４．python中数据类型有哪几种，布尔值有哪些值
	
５．下面那个不是python 的合法标识符(B)
 A int32  B 40XL  C  self  D _name_
 6.超市某款面条１２元一罐，请问lucy带一百元最多买多少罐
 找零多少？
		100//12
		 100%12


day04 笔记

比较运算符：
<　　小于
<=　小于等于
>　　大于
>=　大于等于
==　等于
!=　不等于
语法：
　左表达式　< 右表达式
说明：　比较运算符返回布尔型的值(True/False)

数值对象的构造(创建)函数:

float(obj)  
　用字符串或数字转换浮点数
int(x="0",base=10)
　用数字或运算符转换为整数，如果不给出参数，则返回0
complex(r=0.0,i=0.0) 
　用数字创建一个复数(实部为r,虚部为i)
bool(x) 
 用x传建一个布尔值(True/False)

函数调用：
	函数名(传参列表)
	说明：
		　函数调用是表达式，通常用于返回一个对象的引用关系

bool(x)返回的情况：
	None 空值　　           #False
0, 0.0, 0j (所有的数字为0)  #False
--------以下对象后面会讲--------
'' 空字符串
()　空元组
[]　空列表
{}　空字典
...


练习：
　将数字3.14 用变量pi 绑定
将pi 变量转换为整数用　变量i 绑定
将pi 变量与i变量相减，结果用变量　f绑定
１．判断f是否等于0.14
２．删除所有变量
(用交互模式来测试上述问题)
	　pi=3.14
	 i=int(pi)
	 f=pi-i

预置(內建)的数值型函数
abs(x)          取x的绝对值
round(number[,ndigits]) 对数值进行四舍五入，
其中的ndigits 是小数向右取整数的位数，负数表示向左取整
pow(x,y,z=None) 相当于　x**y 或　x**y%z

help() 查看函数的帮助
>>> help (函数名)
示例：
>>> help(abs) 查看abs函数的帮助文档


语句 statements
	语句是python 执行的的最小单位，语句可以独立执行
	a=100　# 赋值语句
	del a # del 语句
	print("hello") # 表达式语句
	1+2+3 #　表达式语句

多条语句写在一行需要用分号(;) 分开
通常一条语句写在一行内(复合语句除外)


折行符　　\ (反斜杠)
  折行符是告诉解释执行器，下一行的内容也是此语句的内容

示例：
x=1+2+3\
+4
print(x) # 得10

隐式换行：
	所有的括号的内容换行时，　解释执行器会自动去下一行找到相应的括号，知道找到为止
示例：
x=(1+2+3
+4)+5
print(x) # 得１５


基本输入输出函数：
  输入函数：　input
  作用：　
	从标准输入设备上读取一个字符串
	(注：末尾的换行字符会被删除)
  格式：
	input("提示字符串")
  注：返回一个字符串，提示字符串可以为空

  输出函数　print()
   作用：
	　将一些的值以字符串的形式输出到标准设备上，默认为终端
   格式：
	　print(value, ... , sep='', end='\n')
 关键字参数说明：
 sep: 两个值之间的分隔符，默认为一个字格' '
 end:输出完毕后在末尾自动追加一个字符串，默认为换行符'\n'

 ２．分三次输入当前的小时，分钟，秒数，在终端打印此时距离0:0:0:过了多少秒？
 
 1.y=int(input("请输入年数: "))
	 t=365
	 s=y*t
	 r=s//7
	 i=s%7
	 print(y,"年有",r, "周","余",i,"天")


 2.a=int(input("当前小时为:"))
	 b=int(input("当前分钟为:"))
	 c=int(input("当前秒为:"))
	 e=a*3600+b*60+c
	 print("当前距离0:0:0:过了", e , "秒")



if 语句
　作用：　让程序根据条件选择性的执行某条语句或某些语句
语法：
　if 　真值表达式1:
　(四个空格)语句块1...

elif 　真值表达式2:
(四个空格)语句块2...

elif 　真值表达式3:
(四个空格)语句块3...

　...
else :
(四个空格)语句块4...

示例：
t=int(input("请输入一个数："))
if t > 0 :
	print("您输入的为正数")
elif t == 0:
	print("您输入的为零")
elif t < 0:
	print("您数的为负数")
练习：
　1.输入一个季度1~4，输出这个季度有哪几个月，　如果输入不是1~4的整数，则提示输入错误。
 2.输入一个月份1~12,输出这个月在哪个季度，输入其他数字，则提示报错。
 t=int(input("输入一个季度(1~4):"))
　if 1<= t <=4:
	if t == 1:
		print("这个季度有1,2,3月")
	elif t == 2:
		print("这个季度有4,5,6月")
	elif t == 3:
		print("这个季度有7,8,9月")
	elif t == 4:
		print("这个季度有10,11,12月")

else:
	print("您输错了")
	

t=int(input("输入一个月份(1~12):"))
if 1<=t<=3:
	print("第一季度")
elif 4<=t<=6:
	print("第二季度")
elif 7<=t<=9:
	print("第三季度")
elif 10<=t<=12:
	print("第四季度")

else:
	print("您输错了")


　if 语句的嵌套

　　if 语句本身是由多条子句组成的一条复合语句
　　if　语句可以作为语句嵌套到另一个语句的内部


示例
t=int(input("输入一个月份(1~12):"))
if 1<= t <=12:
	if 1<=t<=3:
		print("第一季度")
	elif 4<=t<=6:
		print("第二季度")
	elif 7<=t<=9:
		print("第三季度")
	elif 10<=t<=12:
		print("第四季度")

else:
	print("您输错了")

* 语句(表达式(运算符　，　字面值　，函数　))


条件表达式：
　　语法：
	　表达式1  if 真值表达式　else 表达式2
  作用：
	　如果真值表达式的布尔值为True时，则执行表达式1
	　并返回结果对象的引用，否则执行表达式2　
	　并返回对象引用

  示例：
	商场促销，满一百减二十
  　money=int(input("请输入商品金额:"))
　　 pay=money-20 if money>=100 else money
   
   print("您需要支付:",pay, "元")

练习：
　　１．写一个程序，输入一个数，用if语句计算并打印这个数的绝对值(注：不允许使用abs函数)
２．写一个程序，输入一个数，用条件计算并打印这个数的绝对值
  1.t=int(input("请输入一个数:"))
	if t>0:
	   print(t)
	elif t<0:
		 print(-t)
  2.t=int(input("请输入一个数:"))
	r=-t  if t<0 else t
	print(r)
 pass 语句
 　　作用：
	　通常用来填充语法空白
 　　示例：
 　　输入一个季度，如果输入的不是1~4则打印错误，否则什么都不做
 　　t=int(input("输入一个季度:"))
   if 1<= t <=4 :
	   pass
   else:
	   print("您的分数如有错")


布尔运算
　　运算符：
	 not  and  or  

布尔非操作　not
  语法：
	not x
  作用：　
	　对x进行布尔非操作，如果bool(x)为True则返回False,否则返回True

  注：非零的数都为True，零为False
 
布尔与操作　and
  语法：
	x  and  y
  注：　x, y代表表达式
  作用：
	优先返回假值对象，当x的布尔值为False时，返回x, 否则返回y
  示例：
	True   and  True   #返回True(返回右侧)
	True   and  False  #返回False
	False  and  True   #返回False
	False  and  False  #返回False(返回左侧)
　　如：1 and 2  # 2
	 2 and 1  # 1
	 0 and 0.0 # 0
	 x=int(input("请输入一个月份:"))
	 if 1<= x and x<=12: 等同于　if 1<=x<=12:
	 print("合法月份")

布尔或操作　or
  语法：
	x or y  #等同于 x if bool(x) == True else y
  作用：
	　优先返回真值对象
	　当x为True时，　返回 x ,否则返回 y
  示例：
	True   and  True   #返回True
	True   and  False  #返回True
	False  and  True   #返回True
	False  and  False  #返回False
	x=int(input("请输入一个月份:"))
	if 1　> x and x > 12:
	print("不合法月份")

思考：
　　　s=input("请输入学生成绩:") or '0'
   等同于：
   #
   s=input("请输入学生成绩:")
   if s== " ":
		s=0:
   score =int(s)
   print(score)
   请问以上加的　or 是做什么？

   当不输入内容时，回车后，则将0赋值给s 往下进行执行



正负号运算符：
　　+(正号)　　-(负号)
　　语法：
	　+ 表达式
	　- 表达式
　　注：　正负号运算符是一元运算符(只有一个元素参加运算)
　　示例：
	a = 5
	b = -5
	c = +5
	d = (2-3j)
	e = -d   # (-2+3j)

练习:

将字符串"6.6"转换成浮点数6.6
>>>folat("6.6")

1.北京出租车计价器：
　　　收费标准：
	　　3公里以内收费13元
	　　超出3公里以外，每公里基本单价2.3元每公里
	　　空驶费：　超过15公里后，每公里加收1.15元空驶费
　　要求：
　　　输入公里数，打印书费用金额(以元为单位四舍五入)

t=int(input("输入公里数:"))
d=13
a=2.3
b=2.3+1.15
if t <= 3:
	print(t,"公里收费：",d,"元")
elif t > 3 and t <= 15:
	g=(t-3)*2.3+13
	print(t,"公里收费：",round(g),"元")
elif  t > 15:
	h=(t-15)*b+(t-3)*2.3+13
	print(t,"公里收费：",round(h),"元")
 方法二
km=int(input("输入公里数:")) 
money=13
if km>3:
	money+=(t-3)*2.3+13
if km>15:
	money+=(t-15)*4.45
print(t,"公里收费：",round(money),"元")

２．输入一个学生的三科成绩：
1)打印最高分是多少分？
2)打印出最低分是多少分？


s=int(input("输入一个学生成绩1:"))
b=int(input("输入一个学生成绩2:"))
c=int(input("输入一个学生成绩3:"))
d=max(s,b,c)
e=min(s,b,c)
print("成绩最高为:",d)
print("成绩最低为:",e)

３．给出一个年份，判断是否为闰年并打印
闰年规则:每四年一闰，每百年不闰，每四百年闰
2016 闰年
2100 费闰年
2400 闰年

r=int(input("输入一个年份:"))
if r%4==0 and r%100 !=0:
	print(r,"为闰年")
elif r%100==0 and r%400 ==0:
	print(r,"为闰年")
else :
	print(r,"为平年")

４.BMI指数(Body Mass Index) 又称身高质量指数
BMI 至计算公式在：
BMI =体重(公斤)/　身高的平方(米)
例如：
一个人69公斤的人，　身高是173公分，　则：
　　BMI =69/1.73**2=23.05
标准列表：
　BMI < 18.5       身体过轻
 18.5 <= BMI <24　　正常范围
 BMI > 24　　　　　　　　　体重过重
 输入身高和体重，打印BMI值并打印体重状态

 t=float(input("请输入身高(米):"))
s=float(input("请输入体重(公斤):"))
BMI=s/t**2
if BMI < 18.5 :
	print(BMI,"体重过轻")
elif  18.5 <= BMI < 24 :
	print(BMI,"正常范围")
elif  BMI > 24 :
	print(BMI,"体重过重") 





　day05

字符串 str
  作用：
	用来记录文本信息
  字面值表达式方法：
	用引号括起来的部分都是字符串
	　'  　　单引号
	 "  　　双引号
	 ''' 　三单引
	 """ 　三双引
  　字符串的字面值表达式表示：
	' '
	" "
	''' '''
	""" """
	非空字符串的字面值表达式表示：
	' hello'
	"hello"
	'''hello'''
	""" hello"""
	单引号和双引号的区别：
	　　单引号内得的双引号不算结束符
	　　双引号内得的单引号不算结束符
	例：　　>>> print("I'm a teacher") # I'm a teacher
	三引号字符串的作用：
	　　三引号内可以包含单引号和双引号
	　　三引号字符串中的换行会自动转换为换行符'\n'
	>>>s2='''hhhh!
	...kkkk!'''
	>>>s2
	#  'hhhh!\nkkkk!'
	隐式字符串字面值拼接：
	　　s="I'm a teacher." 'my name is "weimingze"'
	  s='I\'m a teacher.my name is "weimingze"'
	  s='aaa' "bbb" '''ccc''' """ddd"""
	  #'aaabbbcccddd'
  用转义序列代表特殊的字符：
	字符数串字面值中　用字符反斜杠\
	后跟一些字符代表特殊的一个字符
	例如：
	　\'  　代表一个单引号
	　\"   代表一个双引号
	　\n   代表一个换行符
　　字符串的反斜杠转义字符表
　　　\'  单引号
　　　\"  双引号
　　　\\  反斜杠
　　　\n  换行
　　　\r　　返回光标至行首 >>>print("ahdk\rb") #bhdk
　　　\f  换页
　　　\t  水平制表符
　　　\v  垂直制表符
　　　\b  退格　　 >>>print("abcde\bd") #abcd
　　　\0　　字符串，字符值为零  
　　　\xXX  XX为十六进制表示的字符　>>>print("\x41") #A
	>>>print("\x41,\x42,\x43,\x44") # ABCD
	>>>'\x41' # A
	注：(x)　后必须跟两位。
　　　\uXXXX  Unixode 的十六进制表示的字符
>>>print("\u0041") #A  
　　　\UXXXXXXXX Unicode32  的十六进制表示的字符
>>>'\U00000041' # A
ASCII 编码
　　码表见：　　
	$ man ascii
常见的ASCII编码：
字符　　　　　十进制　　　　十六进制
'0'      48       0x30
'A'      65       0x41
'a'      97       0x61
'\0'     0        0x00
'\n'     10       0x0A
UNICODE 编码：
　　全世界字符统一编码
	　分类：
	　　　UNICODE16(两字节)
	   UNICODE32(四字节)
	  例： >>>print("\u9042")  #遂
		　　>>>print("\U00009042")  #遂
 raw 字符串(原始字符串)
	格式：
	　r'字符串内容'
	　r"字符串内容"
	 r'''字符串内容'''
	 r"""字符串内容"""
	 作用：
		让转义符号　\ 无效
	 示例：
	  转义之后的
	 a='C:\newfile\test.py'
	 print(a)
	 #C:
	 ewfile   est.py
	  未定义raw字符串
	 a=r'C:\newfile\test.py'
	 print(a)
	 #C:\newfile\test.py

	 >>>print('\\') # \
	 >>>print(r'\\') # \\
 字符串的运算：
 +  加号运算符用于拼接字符串
 +=　运算符用原字符串与右侧字符串拼接生成新的字符串
 　示例：
 　s='sss' +'hhh'
 　s+='fff'
 　print(s)
 　#ssshhhfff
 　s2=s+s
　　print(s2)
　　#ssshhhfffssshhhfff

* 生成重复的字符串
*= 生成重复的字符串并让原变量绑定生成后的字符串
示例：
　　s="abc" * 3  #s='abcabcabc'
  print(s)
  s2=5*'0'  s2='00000'
  s="123"
  s*=3 # s='123123123'

练习：
　　写一个程序，打印一个高度为４行的矩形方框
　　　要求　：输入一个整数数字，此整数数字代表矩形的高度
输出此矩形
如：
请输入行宽度：10
##########
#        #
#        #
##########
方法一
a=int(input("请输入矩形宽度:"))
print("#"*a)
print("#"+" "*(a-2)+"#")
print("#"+" "*(a-2)+"#")
print("#"*a)
方法二
a=int(input("请输入矩形宽度:"))
d="#"+" "*(a-2)+"#"
print("#"*a,("\n"+d)*2,"\n"+"#"*a)


字符串运算：
  >
  >=
  <
  <=
  ==
  !=
格式：
  x>y
比较规则：
　　字符串x的第一个字母与字符串y的第一个字母比较，如果不相同，则直接得到比较结果;如果相同，则再去第二个字母进行比较，以此类推.
示例：
  >>>"AD">"ABC"     # True
  >>>"ABD">"AE"     # False
  >>>"ABCDEFG"<"Z"  # True
  >>>"ABC" != "CBA" # True
  >>>"AB" <= "ABC"  # True

 in / not in 运算符
 作用：
 　　用于序列，字典，集合等容器中，用于判断某个值是否存在于容器中，如果存在返回True,否则返回False
 　　not in 与　in　运算符的返回结果相反
 格式：
 　　对象　　in  序列
 示例：
 　　>>>"a" in "abc" # True
   True
   >>>a="welcome to tarena"
   >>>"to" in a    # True
   True
   >>>"hello" in a # True
   True

字符串的索引　index
  python 的字符串是不可以改变的字符序列
 　语法：
	字符串[整数表达式]
 　说明：
	　python序列都可以用索引(indefx)来访问序列中的对象
	　python序列的正向索引都是从0开始的，第二个索引为1,......,以此类推，最后一个索引是len(s)-1
	 python序列的反向索引是从-1开始的，-1代表最后一个，-2代表倒数第二个，以此类推，第一个是-len(s).
 示例：>>>a="abcde"
	  >>>a[0]  # 'a'
	  >>>print(a[0]) # a
	  >>>a[1]  # 'b'
	  >>>a[-1] # 'e'

练习：
输入一个字符串
　　１．打印这个字符串的第一个字符
　　２．打印这个字符串的最后一个字符
　　３．如果此字符的长度为偶数，打印一个'|',如果长度为奇数，打印中间的字符
方法一
a=input("请输入一个字符串:")
print("第一个字符为:",a[0])
print("最后一个字符为:",a[-1])
e=len(a)-1
t=int(e/2)
if len(a)%2 ==0 :
	print("|")
else :
	print("中间的字符:",a[t])
 方法二
a=input("请输入一个字符串:")
print("第一个字符为:",a[0])
print("最后一个字符为:",a[-1])
if len(a)%2 ==0 :
	print("|")
else :
	d=len(a)//2
	print("中间的字符:",a[d])


切片　slice
  从字符串序列中取出相应的元素，重新组成一个字符串序列
  语法：
	字符串[(开始索引b):(结束索引e)(:(步长s))]
	注：　小括号() 括起的部分代表可以省略
   语法说明：
　　　1．开始索引是切片切下的位置，0代表第一个元素，1代表第二个元素，-1代表最后一个元素
   2．结束索引是切片的终止索引(但不包含终止点)
   3．步长是切片每次获取当前元素后移动的方向和偏移量
	1)没有步长，相当于取值完毕后向右移动一个索引的位置(默认为1)
   　2)当步长为正整数时，取正向切片
   　3)当步长为负整数时，取负向切片
	　当步长为负整数时，默认的起始位置为最后一个元素，终止位置是第一个元素的当前位置
  示例：
  >>>　x="asdf"
  >>> x[1:3]  # sd
  >>> 'sd'
  >>>x[:3]
  >>>'asd'
  >>>x[1:]
  >>>'sdf'
  >>>x[-5:100]　　#可以超出
  >>>'asdf' 
  >>>x[2:-1]
  >>>'d'
  >>>[:]
　　>>>'asdf'
  >>>[::2]
  >>>'ad' 

 练习　输入一个字符串，判断这个字符串是否是回文
 　　回文示例：abcba
   回文是指中心对称的文字
a=input("请输入一个字符串:")

if a[:] == a[::-1]:
	print("是回文",a)
else :
	print("不是回文")


python3 中常用的序列函数：
　len(sep)　返回序列的长度
　max(x) 　　返回序列的最大值的元素
　min(x) 　　返回序列的最小值的元素

字符串编码转换函数：
　　ord(c) 返回一个字符的Unidcode值
　　chr(i) 返回i这个值所对应的字符
示例：
　　>>>i=ord('魏')
  >>>print(i)  # 39759
  >>>c=chr(39759)
  >>>print(c) # '魏'
练习
 写一个程序，输入一段字符串，如果字符串不为空，则把第一个字符的UNICODE编码值打印出来
 写一个程序，输入一个整数值(0~65535)
 打印这个编码所对应的字符
a=input("输入一个字符串:")
if len(a) != 0 :
	print(ord(a[0]))
else :
	print("输入有错")
d=int(input("输入一个整数值(0~65535):"))
if 0<= d <= 65535:
	print(chr(d))
else :
	print("输入有错")

整数转换为字符串函数：
　　hex(i) 将整数转换为　十六进制字符串
　　oct(i) 　将整数转换为　八进制字符串
 　bin(i)  将整数转换为　二进制字符串
　　
字符串构造函数：
　 str(obj='') 将对象转换为字符串


示例：
>>>hex(10) #0xa
>>>int(hex(12),2) # 12
>>>str(True) # 'True'


练习：
　　输入三行文字，让这三个字在方框内居中显示
　　(请不要输入中文)
如：
　　请输入第一行：hello tarena!
  请输入第二行：my name weimingze.
  请输入第三行：touday is sunday!
 显示如下：
+-------------------+
|   hello tarena!   |
| my name weimingze |
| touday is sunday! |
+-------------------+





day 06

python3 中常用的字符串方法(method)
  方法的调用语法：
	对象.方法名(方法传参)
  说明：
	方法的条用通函数同函数调用一样属于表达式
  示例：
  　'abc'.isalpha() # 判断'abc'是否为全英文字母
	123.isalpha() # 错的，123没有 isalpha方法
　　>>>a='abc'
  >>>a.isalpha()   # True
  >>>b='123'
  >>>b.isalpha()  # False
S.isdigit() 判断字符串中的字符是否全为数字 
S.isalpha() 判断字符串是否全为英文字母 
S.islower() 判断字符串所有字符是否全为小写英文字母 
S.isupper() 判断字符串所有字符是否全为大写英文字母 
S.isspace() 判断字符串是否全为空白字符 
S.center(width[,fill]) 将原字符串居中，左右默认填充空格 
示例：　
　>>>"abc".center(20,'#')
#  ########abc#########

S.count(sub[, start[,end]]) 获取一个字符串中子串的个数 
>>>s="hello world"
>>>s.count('o')
# 2
>>>s.count('l',1,5)
# 2
>>>s.count('o',6)
# 1


S.find(sub[, start[,end]]) 获取字符串中子串sub的索引,失败返回-1 
>>>s="hello world"
>>>s.find('w')
# 6
>>>s.find('o',3,5)
# 4

S.strip() 返回去掉左右空白字符的字符串 
>>>s="  \r\n hello   \t\r"
>>>s.strip()
# hello
>>>d="   \r\n  hello world \r\n  "
>>>d.strip
# hello world
S.lstrip() 返回去掉左侧空白字符的字符串
>>>d="   \r\n  hello world \r\n  "
>>>d.lstrip()
# hello world \r\n  '
S.rstrip() 返回去掉右侧空白字符的字符串

字符串  
S.upper() 生成将英文转换为大写的字符串 
S.lower() 生成将英文转换为小写的字符串 
S.replace(old, new[, count]) 将原字符串的old用new代替，生成一个新的字符串
>>>s="hello world"
>>>s.relace('l','L')
# heLLo worLd 
S.startswith(prefix[, start[, end]]) 返回S是否是以prefix开头，如果以prefix开头返回True,否则返回False, 
S.endswith(suffix[, start[, end]]) 返回S是否是以suffix结尾，如果以suffix结尾返回True,否则返回False 
以下是不常用的  
S.title() 生成每个英文单词的首字母大写字符串
>>>s="hello world"
>>>s.title()
# Hello Wlorld 
S.isnumeric() 判断字符串是否全为数字字符 


练习
　　输入一个字符串：
１．判断您输入的字符串有几个'e'
2.判断您输入几个空格
３．判断您输入的字符串是否为问号结尾
a=input("请输入一个字符串:")
t=a.count("e")
d=a.count(" ")
print("e的个数为:",t)
print("空格的个数为:",d)
if a.endswith("?"):
	print("以问号结尾")
else:
	print("不以问号结尾")

字符串格式化表达式
　　作用：
	　生成一定格式的字符串
　　运算符
	　%
　格式：
　　格式化字符串　% 参数值
　　　或
　　　格式化字符串　% (参数值１，　参数值２，....)
示例：
　　fmt="姓名"：　%s, 年龄：　%d
  name = "张飞"
　　age = 20
  print(fmt % (name,age))

 占位符和类型码

占位符类型码　　　　意义


%s 　　　　　　　　　　字符串 
%r 　　　　　　　　　　字符串，使用repr 而不是str 
%c 　　　　　　　　　　整数转为单个字符

例：>>>'%c'%20013 等同于chr(20013) #'中'

%d 　　　　　　　　　　十进制整数 
%o 　　　　　　　　　　八进制整数 
%x 　　　　　　　　　　十六进制整数(字符a-F小写) 
%X 　　　　　　　　　　十六进制整数(字符A-F大写) 
%e 　　　　　　　　　　指数型浮点数(e小写),如2.9e+10 
%E 　　　　　　　　　　指数型浮点数(E大写),如2.9E+10 
%f, %F 　　　　　　浮点十进制形式 
%g, %G 　　　　　　　十进制形式浮点或指数浮点自动转换 
%% 　　　　　　　　　　等同于一个%字符 

占位符　% 和类型码之间的格式语法：
　　% [格式语法]　　类型码　(d,s,f等)
　　格式与法：
　　　- 左对齐
+ 显示正负号
0 补零
宽度
宽度.精度
示例：
"%10d" %123    # '       123'   注：(宽度为10,负号左对齐　，不加正负号为右对齐)
"%-10d" %123   # '123       '
"-610s" %"abc"   # 'abc     '
"%-5s" % 'abc' #'abc  '
"%+10d" %123   # '　　　　　　+123'
"%010d" % 123  # '00000000123'
"%.2f" %3.141592653585932    # '3.14'
"%.5f" %3.141592653585932    # '3.14159'
"%7.2f" %3.141592653585932   # '   3.14'
"%e" %299790000.0            # '2.997900e+08'
"%E" %299790000.0            # '2.997900E+08'
"%f" % 299790000             # '299790000.000000'
"%F" % 299790000             # '299790000.000000'
"%f%%" % 0.018  # 0.018000%
练习：
１．输入三行文字，让着三行文字以20个字符的宽度右对齐
思考：能否以最长字符串右对齐，左侧填充空格
a=input("请输入第一行文字:")
b=input("请输入第二行文字:")
c=input("请输入第三行文字:")
t=max(len(a),len(b),len(c))
m=str(t)
print(m)
print(("%"+m+"s") %a)
print(("%"+m+"s") %b)
print(("%"+m+"s") %c)
方法二
a=input("请输入第一行文字:")
b=input("请输入第二行文字:")
c=input("请输入第三行文字:")
t=max(len(a),len(b),len(c))
print("%%%ds" %t %a)
print("%%%ds" %t %b)
print("%%%ds" %t %c)

循环语句(有两种)：
while 语句
for   语句
　　问题：
	请输入一个整数，让程序输出n行的
	hello  1
	hello  2
	...

	hello  n
while 语句
  作用：
	根据一定条件，重复的执行一条语句或多条语句
  语法：
	while 真值表达式：
		　　语句块1...
	else:
		语句块2
  说明：
  1．先执行真值表达式，测试布尔值为True或False
  2.如果真值表达式的测试值为True,则执行语句块1,然后再返回到第一步重复进行测试
  3．如果真值表达式的测试值为False,则执行else子句中的语句块２，然后结束此while语句的执行，如果没有else子句，则直接结束while语句的执行
  4．else子句部分可以省略(同if语句类似)
  示例：
  i=int(input("请输入打印行数:"))
  n=1
  while n<=i:
	  print("hello",n)
	  n+=1
打印(1~20)的整数
n=1
while n <= 20:
	print(n)
	n+=1

练习：
　　输入一个整数n:
  打印n以内大于零的偶数(不包含n)
2.打印从零开始的浮点数，没个数增加0.5,打印出10以内所有这样的数
３．打印1~20的整数，打印在一行显示，每个数字之间用一个空格分隔  
1.a=int(input("输入一个整数:"))
  b=2            |   b=1
  while b<a:     |   while b < a :
	  print(b)   |       if b%2 ==0 :
	  b+=2       |           print(b)
				 |       b+=1
2.q=0
  while q < 10:
	  print(float(q))
	  q+=0.5
3.m=1
  while m<=20:
	  print(m,end=" ")
	  m+=1
  else :
	  print()


练习：
1.打印1~20的整数，每行五个，打印四行，如：
１２３４５
６７８９１０
．．．
提示需要嵌入if语句打印换行符
2.用while语句打印10~1之间的整数
3.用while语句实现打印三角形，输入一个整数，表示三角形的宽度和高度，打印相应记得三角形
*
**
***
****
a=1
while a <=20:
	print(a,end=" ")
	if a%5==0:
		print()
	a+=1

d=10
while d!=0:
	print(d)
	d-=1

r=int(input("输入数:"))
e=1
while e<=r:
	print("*"*e)
	e+=1


whlie 语句的注意事项：
１．要控制循环的真值表达式的值来防止死循环
２．通常用真值表达式中的循环变量来控制循环条件
３．通常在循环语句块内需要改变循环变量来看控制循环的次数和变量的方向


while 语句嵌套
　　while 语句本身是语句，和其他语句一样可以嵌套在其他复合语句中(如：if语句，while语句，for语句...的内部)
while 语句嵌套示意：
　　while  真值表达式：
	　　...
	  while 真值表达式2:
		  ....
	  else:
		  ....
  else:
	  ....

示例：
a=1
while a<=20:
	i=1
	while i<=20:
		print(i,end=" ")
		i+=1
	else :
		print()
	a+=1


练习：
１．输入一个数，打印指定宽度的正方式：
如：
请输入：５
打印如下：
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
a=int(input("请输入一个数:"))
b=1
print("请输入:",a)
while b<=a:
	c=1
	while c<=a:
		print(c,end=" ")
		c+=1
	else :
		print()
	b+=1


break 语句：
　　作用：
	　用于循环语句(while,for语句)中，用来终止当前循环语句的执行
说明：
１．当break语句执行后，此循环语句break之后的语句将不再执行
２．break 语句通常和if 语句组合使用
３．break语句终止循环时，循环语句的else子句将不再会被执行
４．break语句只能终止当前循环的执行，如果有循环嵌套时，不会跳出嵌套的外重循环
５．break语句只能循环语句(while或for语句)
示例：
　i=1
while i< 10:
	print("循环开始时的i=",i)
	if i==5:
		break
	print("循环结束时的i=",i)
	i+=1
else:
	print("结束")
print("程序即将退出,i=",i)

a=int(input("请输入一个数:"))
b=1
print("请输入:",a)
while b<=a:
	c=1
	while c<=a:
		print(c,end=" ")
		if c==4:
			break
		c+=1
	else :
		print()
	b+=1

死循环　death loop
  1.死循环是指循环条件一直成立的循环
  2．死循环通常用break语句来终止循环
  3．死循环的else子句永远不会执行
示例：
用input输入一些文字，当输入三个星号时代表输入结束
　　打印您刚输入的所有文字(换行是自动加上换行符)

s=" "  #先创建一个变量，用来保存字符串

while True:
	a=input("请输入文字(***结束):")
	if a=="***":
		break
	s+=a+"\n"

print("您刚才输入的是:")
print(s)


练习
　　用while语句实现打印三角形，输入一个整数，表示三角形的宽度和高度，打印相应得三角形

１．打印如下结果
*
**
***
2.打印如下结果

  *
 **
***

3.打印如下结果
***
 **
  *

4.打印如下结果

***
**
*
2.写一个程序，输入一个开始的整数值用变量begin绑定

输入一个结束的整数值用变量eng绑定
打印从begin到end(不包含end)的每个整数(打印在一行内)
如：
请输入开始值：8
请输入结束值：30

打印结果：
8 9 10...28 29 30
附加思考：
　　如何实现每5个数字打印在一行

３．用while循环生成一个字符串：
'ABCD...XYZ'并打印
'AcBbCcDd...XxYyZz'并打印
提示：
　　用chr和ord函数
a=int(input("请输入一个整数:"))
t=1
while t <= a:
	print("*"*t)
	t+=1


b=int(input("请输入一个整数:"))
a=int(b)
while b>=1:
	d="*"*b
	print("%%%ds" %a %d)
	b-=1

c=int(input("请输入一个整数:"))
while c >= 1:
	print("*"*c)
	c-=1

s=int(input("请输入一个整数:"))
h=1
while s>=h:
	p="*"*h
	print("%%%ds" %s %p) 
	h+=1

 
begin=int(input("请输入一个开始的整数值:"))
end=int(input("请输入一个结束整数值:"))
print("开始值为:",begin)
print("结束值为:",end)
i=1
while begin<=end:
	print(begin,end=" ")
	if i%5==0:
		print()
	begin+=1
	i+=1

ui=65
while ui<=90:
	print(chr(ui),end=" ")
	ui+=1

ui=65
op=97
while ui<=90 and op<= 122:
	print(chr(ui)+chr(op) ,end=" ")
	ui+=1
	op+=1



day 07

for 语句(循环语句)
　　作用：
	用来遍历可迭代对象元素
　　语法：
　　for  变量列表　in 可迭代对象：
	　　　语句块1...
  else:
	  语句块2...
 语法说明：
 １．可迭代对象每次提供一个元素依次赋值给变量列表中的变量，赋值完毕后执行语句块1，重复执行此步骤
 ２．当可迭代对象不能提供数据时，执行else子句部分的语句块2，然后退出循环
 ３．else子句部分可以省略(同while语句类似)
 ４．当在语句内部用break终止循环时，else子句部分语句块2不会执行

 注：可迭代对象是指能依次获取数据元素的对象

示例：
s="abcde"
for x in s:
	print("----->",x)
else:
	print("程序终止")

s="abcde"
for x in s:
	print("----->",x)
	if x=='c':  # 此时else 子句部分不会执行
	break  
else:
	print("程序终止") 

练习　
写程序，任意输入一行字符串，打印这个字符串内有多少空格' ' 
s=input("请输入一行字符串:")
a=0
for x in s:
	if x==" ":
		a+=1
print(a)

i=0
s=input("请输入一行字符串:")
a=0
length=len(s)
while i < length:

	if x==" ":
		a+=1
	i+=1
print(a)

range函数
作用：
　　用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)
调用格式：
　　range(stop)
  从零开始，每次生成一个整数后加一操作，直至stop为止(不包含stop)
  range(start,stop[,step]) 从start开始，每次生成一个整数后移动step,直至stop为止(不包含stop,且step可以为负数)
  示例：
  range(4)  # 0 1 2 3
  range(3,6) # 3 4 5
  range(1,10,2) # 1 3 5 7 9 
  range(5,0,-2) # 5 3 1
  range(4,1)    # 空
  for x in range(4):
	  print(x)

   # 0 1 2 3 

练习：
用 for 执行
2.写一个程序，输入一个开始的整数值用变量begin绑定

输入一个结束的整数值用变量eng绑定
打印从begin到end(不包含end)的每个整数(打印在一行内)
如：
请输入开始值：8
请输入结束值：30

打印结果：
8 9 10...28 29 30
附加思考：
　　如何实现每5个数字打印在一行

begin=int(input("请输入开始值:"))
end=int(input("请输入结束值:"))
i=1                       |i=begin
for a in range(begin,end):|while 
	print(a ,end=" ")     |
	if i%5==0:
		print()
	i+=1




请问以下代码说明什么问题？
i=10
for x in range(1,i):
	print(x)
	i -= 2


for 语句嵌套:
  示意：
  for x in "ABC"：
	　　for y in "123":
		  print(x+y)
	

练习
 用　for 循环嵌套打印以下矩形:
 (输入一个数n(10以内)　代表矩形的宽度和高度)
 打印如下：
 请输入：5
 1 2 3 4 5
 2 3 4 5 6
 3 4 5 6 7
 4 5 6 7 8
 5 6 7 8 9
b=int(input("请输入一个整数(10以内):"))
if 0< b <=10:
	for s in range(0,b):
		for d in range(1,b+1):
			print(s+d ,end=" ")
		print()
else:
	print("输入有错")

３．用for循环生成一个字符串：
'ABCD...XYZ'并打印
'AcBbCcDd...XxYyZz'并打印
提示：
　　用chr和ord函数
x=0
for a in range(65,91):
	b=97
	q=[]
	while b<= 122:
		q+=chr(b)    
		b+=1
	print(chr(a)+q[x],end=" ")
	x+=1
	a+=1


continue 语句
　　作用：
	用于循环语句(while,for语句)中，不再执行本次循环内continue之后的语句，重新开始一次新的循环
　　说明：
　　１．在while语句中执行continue语句，将直接跳转到whlie语句的真值表达式处重新判断循环条件
　　２．在for语句中执行continue语句，将会从可迭代对象中取下一个语句，绑定变量后再次进行循环
示例：
打印5以内的整数，但不打印2:

for i in range(5):
	if i　==　2:
		contiue #如果i等于2，重新开始一次新的循环
	print(i)


问题：
　　输入一个开始的数用begin绑定
　　输入一个结束的数用end绑定
　　打印begin~end之间所有的奇数
begin=int(input("请输入一个开始的整数:"))
end=int(input("请输入一个结束的整数:"))
for s in range(begin,end):
	if s%2==0:
		contiue
	prlint(s)

begin=int(input("请输入一个开始的整数:"))
end=int(input("请输入一个结束的整数:"))
i=begin
while i<end:
	if i%2==0:
		i+=1
		continue
	print(i)
	i+=1

练习：
　　写一个程序，求1~100之间所有不能被5,7,11整除的数的和
d=0
for s in range(1,101):
	if s%5==0 or s%7==0 or s%11==0:
		continue
	 d+=s

print(d)



列表 list
列表的定义：
　　列表是由一系列元素组成的，元素和元素之间可能没有任何关联关系，但他们之间有先后顺序关系
列表是一种容器
列表是一种序列
列表是可以被改变的序列

python中的序列：
字符串　　 str
列表     list
字节串   bytes
字节数组  bytearray

创建空列表的字面值：
　L = [] # L　绑定空列表
创建非空列表的字面值：
L=[1,2,3,4]
L=['Beijing','shanghai','shenzhen']
L=[1,'two',3.3,'四']
L=[1,2,[3.1,3.1,3.3],4]

列表的构造函数　list
list()          #生成一个空列表，等同于[]
list(iterable)  #用可迭代对象传建一个列表
示例：
>>>list()              # []
>>>list("hello")       # ['h','e','l','l','o']
>>>list(range(1,10,2)) # [1,3,5,7,9]
列表的运算：
运算符：
　+  +=  *  *=
+ 用于拼接列表
　 x=[1,2,3]
  y=[4,5,6]
  z=x+y    # z=[1,2,3,4,5,6]
+= 永远列表与右侧列表拼接，并用变量绑定新列表
　　　x=[1,2,3]
   x+=[9,8,7]   # x=[1,2,3,9,8,7]
*　　生成重复的列表
　　　x=[1,2]*3  # x=[1,2,1,2,1,2]
   y=3*[5,6]  # y=[5,6,5,6,5,6]
*= 生成重复的列表，并给原变量赋值
　　　x=[3,4]
   x *= 2    # x=[3,4,3,4]
   y=3
   y *= [7,8] # y=[7,8,7,8,7,8]
注：　x*=3 等同于　x=x*3

列表的比较运算：
　　运算符：
	< <= > >= == !=
示例：
　　　[1,2,3] < [1,2,4]  # True
   [1,3] > [1,2,4]    # True
   [5] < [5,0]        # True
   ["ABC","123"] > ['abc','456'] # False
   [1,'two'] > ["two",1]   # TypeError(类型错误)
   [1,2]<[3.3,4]　　　　　　# True


 练习：
 　　输入一些行文字，将这些文字保存在一个列表l中，当输入空行时结束输入，并打印列表l的内容
d=[]
while True:
	s=input("请输入文字:")
	if s==" ":
		break
	d+=[s]
print(d)




练习：
１．输入一个Unicode的开始值　用变量begin绑定
输入一个Uniccode的结束值　用stop绑定
打印开始值至结束值之间的所有对应的文字，生成字符串并打印
请输入开始值：　20013
请输入结束值：　20050

begin=int(input("请输入开始值:"))
seop=int(input("请输入一个结束值:"))
a=" "
for s in range(begin,seop):
	a+=chr(s)
print(a)

2.输入一个整数(代表树干的高度)
打印如下一颗圣诞树

输入:2
 *
***
 *
 *
输入：３
　　*
 ***
*****
  *
  *
  *


g=int(input("请输入一个整数:"))
i=1
p=1
while i <= g*2-1:
	r="*"*i
	print(r.center(g*2-1," "))
	i+=2
while p<=g:
	d="*"
	print(d.center(g*2-1," "))
	p+=1

3.输入如下圣诞树：
输入：３
　　1
 222
33333
  *
  *
  *

r=int(input("请输入一个整数:"))
i=1
a=1
e=1
while i <= r*2-1:
	d=(str(a))*i
	print(d.center(r*2-1))
	i+=2
	a+=1
while e <= r:
	z="*"
	print(z.center(r*2-1))
	e+=1

4.输入一个正整数，打印这个数是否是素数
素数也叫质数，只能被1和自身整除
如：
请输入：5
5　是素数
ru=int(input("请输入一个正整数:"))
for s in range(1,ru+1):
	if s==2:
		print("是素数")

	if s==1 or s==ru :
		continue
	if ru%s==0:
		print("不是素数")
		break
	else:
		print("是素数")
		break



day 08
 

列表的in / not in 运算符
　判断一个对象是否存在于容器内，如果存在返回True,否则返回False
用法：　同字符串的　in 相同
语法：
　　数据对象　in 容器
示例：
a = [1,"two",3.3,"四"]
　1 　　in a 　　　　#  True
　2 　　in a 　　　　#  False
3.3 　in a 　　　　#　　???   浮点数小数点后面几位有精度区别，可能有差别
"4" not in a 　#　　True

列表的索引：
　　语法：
　　　列表[整数表达式]
　　用法：

　　取值时，等同于字符串的索引操作
　　索引分为正向索引和反向索引，规则与字符串索引规则完全相同


列表的索引赋值
　　列表是可变的序列，可以通过索引赋值改变列表中的元素
示例：
　　l =[1,2,3,4]
  l[2]=3.3   # 将第三个元素改为3.3


列表的切片
　　语法：
　　　列表[:]
　　　列表[::]
　　　列表的切片取值时，返回一个列表，规则等同于字符串切片规则

列表的切片赋值：
　　作用：
	可以改变列表的排序，可以插入和修改数据
	可用切片改变列表的对应元素
　　　语法：
	　列表[切片]＝可迭代对象
	注：　赋值运算符的右侧必须是一个可迭代对象
示例：
l=[2,3,4]
l[0:1]=[1.1,2.2]  # l=[1.1,2.2,3,4]
l=[2,3,4]

l[1:]=[3.3,4.4,5.5] #l=[2,3.3,4.4,5.5]
l=[2,3,4]

l[:]=[0,1]  # l=[0,1]
l=[2,3,4]

l[1:1]=[0,0] # l=[2,0,0,3,4]
l=[2,3,4]
l[0:0]=[0,1] # l=[0,1,2,3,4]


切片赋值的注意事项：
　　对于步长不等于1的切片赋值，赋值运算符右侧的可迭代对象提供的元素个数一定要等于切片切除的段数
例：
　　l=[1,2,3,4,5,6]
l[::2]="abc" # ['a', 2, 'b', 4, 'c', 6]

#以下切出三段

del 语句　用于删除列表的元素
　　语法：
　　　del 序列　[整数表达式]

　　　del 序列[切片]
示例：
　l=[1,2,3,4,5,6]
del l[-1]    #删除最后一个
del l[0]    # 删除第一个
del l[::2]  # 删除 2,4

python3常用于序列的函数
len(sep)  返回容器的元素个数
max(x)　　返回序列的最大值元素

min(x)返回序列的最小值元素

sum(x)返回序列中所有元素的和(元素必须是数值类型)
any(x)　　真值测试，如果容器内其中一个值为True,则返回True,否则返回False
all(x)  真值测试，容器内所有元素的布尔值为True在返回True



python3 中常用的列表方法(method)


L.index(v [, begin[, end]])     返回对应元素的索引下标, begin为开始索引，end为结束索引,当 value 不存在时触发ValueError错误 
L.insert(index, obj)    将某个元素插放到列表中指定的位置 
L.count(x)              返回列表中元素的个数 
L.remove(x)             从列表中删除第一次出现在列表中的值 
L.copy()         复制此列表（只复制一层，不会复制深层对象) 
L.append(x)                      向列表最后追加单个元素 
L.extend(lst)                          向列表追加另一个列表 
L.clear()          
清空列表,等同于 L[:] = [] 
L.sort(reverse=False) 将列表中的元素进行排序，默认顺序按值的小到大的顺序排列 
L.reverse() 
列表的反转，用来改变原列表的先后顺序 
L.pop([index])
 删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系 



示例：
l=     [1,2,3]
l2=l
l2.remove(2)#l2=[1,3] l=[1,3]

l=[4,5,6]
l2=l[:]
l2.remove(5) #l2=[4,6] l=[4,5,6]
 s=[3,1,2,4,3,5]
 s.index(3,1,5)   # 4 返回索引下标
  s=[3,1,2,4,3,5]
 s.count(3)       # 2
  s=[3,1,2,4,3,5]
 s.remove(3)      # [1,2,4,3,5] 第一个3被删除
  s=[3,1,2,4,3,5]
　s.insert()
　



练习：
　　写一个程序，让用户输入很多个正整数，当输入小于零的数时结束
输入
１）打印这些数的和
２）打印这些数的最大数和第二大数
３）删除最小的一个数
４）按原来输入的顺序打印出剩余的这些数=
a=[]
d=[]
while True:
	s=int(input("请输入一个正整数:"))
	if s<0:
		break
	a.append(s)
print(a)
d=a.copy()   # 复制原列表，供以后使用
print("和为",sum(a))
a.sort(reverse=False)
print("最大值，第二大值",a[-1],a[-2])
p=a.pop(0)  
d.remove(p)
print("原顺序剩余的数",d)



浅拷贝　shallow copy 和 深拷贝　deep copy


浅拷贝：
　　是指复制过程中，只复制一层变量，不会复制深层变量绑定的对象的复制过程
示例：
　l = [3.1,3.2]
 l1=[1,2,l]    # l1=[1,2,[3.1,3.2]]
 l2=l1.copy() #浅拷贝 l2=[1,2,[3.1,3.2]]
 l[0]=3.14    # l=[3.14,3.2]
  #        l1=[1,2,[3.14,3.2]]
  #        l2=[1,2,[3.14,3.2]]
 l1[0]=5      # l1=[5,2,[3.14,3.2]]
 l2=[1,2,[3.14,3.2]]
 # l1[2]和l2[2]共同拥有l的绑定关系

 深拷贝：

 示例：
 　　import copy   # 导入copy模块

　l = [3.1,3.2]
 l1=[1,2,l]    # l1=[1,2,[3.1,3.2]]
 l2=copy.deepcopy(l1) #深拷贝 l2=[1,2,[3.1,3.2]]
 l[0]=3.14    # l=[3.14,3.2]
  #        l1=[1,2,[3.14,3.2]]
  #        l2=[1,2,[3.1,3.2]] 此列表不受影响


 注意事项：
  　深拷贝通常只对可变对象进行深层复制，不可变对象通常不会被复制
 理解：
 import copy # 导入复制模块
 l1=[1,2,[3.1,3.2]]
　l2=l1 　　　# l1和l2绑定的是同一个对象
　l3=l1.copy()　　# 浅拷贝　
　l4=copy.deepcopy(l1)　　# 深拷贝
　l1[2][0]=3.14　　# 把3.1改为3.14
深拷贝和浅拷贝的复制过程中是不会对(对象)进行拷贝对象的元素id不会改变，如：　id(l4[0])id(l4[1])中的1,2　不会改变
但是其他的id 会改变　，　如：id(l4[2])中的[3.1,3.2]这个列表的id 改变了

 以上可用 id()验证

列表与字符串：
　１．列表和字符串都是序列，元素之间有先后顺序
　２．字符串是不可变的序列，而列表是可变的序列
　３．字符串中的每个元素只能存储字符，而列表可以存储任意类型的元素
　４．列表和字符串都是可迭代对象

字符串文本解析方法　split 和 join
 S.split(sep=None)
 将字符串使用sep作为分隔符分割S字符串，返回分割后的字符串列表，当不给定参数时，用空白字符作为分隔符分割
 S.join(iterable) 用可迭代对象中的字符串，返回一个中间用S进行分隔的字符串
 示例：
 s='Beijing is capital'
 L=s.split(' ') # L=['Beijing, is, capital']
 L=["C:","Programe files","Python3"]
 s='\\'.join(L)

 #s="C:\\Programe files\\Python3"
 print(s) # 'C:\Programe files\Python3'


练习：
　　有字符串"hello",生成'h e l l o'和'h-e-l-l-o'
s="hello"
b=" ".join(s)
a='-'.join(s)
print(b)
print(a)



列表推导式　list comprehension
 列表推导式是用可迭代对象依次生成带有多个元素的列表的表达式
 作用：
 用简易的方法生成列表
 语法：
 [表达式　for 变量 in 可迭代对象]
 或

 [表达式　for 变量 in 可迭代对象 if 真值表达式]
 问题：
 [1,4,9,16,25,...,81]
 以前的方法：
 l=[]
 for x in range(1,10):
	 l.append(x**2)

 print(l)
 用列表推导式：
 l=[x**2 for x in range(1,10)]

 print(l)

 练习：
 　　用列表推导式生成1~100内奇数的列表
 方法一：
 l=[x for x in range(1,100,2)]
 方法二：
 l=[x for x in range(1,100) if x%2==1]
 


 示例：
 　　生成[1,9,25,49,81]的列表，跳过所有偶数
l=[x**2 for x in range(1,10)　if x%2 !=0]


练习：
　　输入一个数作为开始的数，用begin绑定在输入一个结束的数用end绑定 将开始至结束的数中，平方加1能被7整除的数放入列表中
请输入开始数：1
请输入结束数：20
a=int(input("请输入一个开始数:"))
b=int(input("请输入一个结束数:"))
f=[x for x in range(a,b) if (x**2+1) % 5 == 0]
print(f)



列表推导式的嵌套：
　　语法：
	[表达式1
		for 变量1 in 可迭代对象1 if 真值表达式1
		   for 变量2 in 可迭代对象2 if 真值表达式2 ]


示例：
　　想生成['A1','A2','A3','B1','B2','B3','C1','C2','C3']
[x+y for x in "ABC" for y in "123"]





练习：
　１．输入一个整数n 代表结束的数
将1~n之间所有的素数计算出来并存入列表l中
1)最后打印此列表中觉得全部素数
2)打印这些素数之和
c=[]
n=int(input("请输入:"))
for x in range(2,n):br
	for y in range(2,x):
		if x%y==0:
			break
	else:
		c.append(x)
print(c)
print(sum(c))
２．求100以内有哪些整数与自身加1　的乘积再对11求余的结果等于8
打印这些数，将这些数存入列表当中(建议用列表推导式)
a=[x for x in range(1,101) if ((x+1)*x)%11==8]
print(a)
３．计算20个斐波那契数(fabonacci数)
存于列表中，最后打印这20个数
1,1,2,3,5,8,13,...
(从第三个数起，后一个数是前两个数之和)

d=[1,1,2] 
i=1
a=2               |l=[1,1]
while i<18:       |while len(l)<20:
	f=d[i]+d[ a]  |    l.append(l[-1]+l[-2])
	d.append(f)   | 
	i+=1          |print(l)
	a+=1
print(d)
方法二：
l=[]
a=1
b=1
l.append(a)
l.append(b)
while len(l)<20:
	c=a+b         |l.append(a+b)
	l.append(c)   |a,b=b,a+b
	a=b           |
	b=c           |
print(l)

day 09


元组　tuple
  元组是不可改变的序列；同list一样，元组可以存放任意类型的元素
  表示方法：　　
	用小括号()括起来，单个元素括起来后加逗号(,)区分单个对象还是元组
  创建空元组的字面值
  t=()
  创建非空元组的字面值
  t=200,
  t=(20,)
  t=(1,2,3)
  t=100,200,300   # (100,200,300)
　　t=(100+200,)    # (300,)
 

type(x)　函数用来返回　x　的类型
　
示例：

　>>>a=100
　>>>type(a)    # <class 'int'>

　>>>b=(100,200,300)
　>>>type(b) is tuple   # True

元组的错误示例：
　t=(20)

x,y,z=100,200,300    #　序列赋值
x,y,z=(100,200,300)　　#　序列赋值
x,y,z=[100,200,300]　　#　序列赋值　
x,y,z="ABC"　　　　　　　　　　#　序列赋值　
元组的构造(创建)函数 tuple
tuple()  生成一个空元组，等同于()
tuple(iterable)  用可迭代对象生成元组
t=tuple([2,3,5,7])


元组的运算：
元组的所有运算同列表的运算方式相同
算术运算：
　+ += * *=
比较运算：
　> >= < <=  == !=
in / not in　　运算 
  
示例：
  t=(1,2)
  t+=(4,5)    # t=(1,2,4,5)
　　(1,2)<(1,3) #True
  t=(2,3,4,5)
  1 in t # False
  2 in t # True

索引　和切片：
元组的索引和切片等同于列表索引和切片
元组的切片返回一个元组
元组不能索引赋值和切片赋值


示例：
 t=(1,2,3,4,5,6,7)
 t[0]   #1
 t[::2] # (1,3,5,7)


 元组的方法
 T.count(value)  返回元组个数
 T.index(value,[start,[stop]])　　返回某个元素在元组的索引位置

 序列相关的函数：
 len(x)
 max(x)
 min(x)
 sum(x)
 any(x)
 all(x)
 str(obj)　将对象序列转化为字符串
 list(iterable)
 tuple(iterable)
reversed(seq) 　返回反向顺序的迭代器对象
sorted(iterable,reverse=F
alse)
返回已排序的列表
示例：
　l=[2,3,5,7]
for x in revered(l):
	print(x)    # 打印　7,5,3,2

for x in reversed(range(1,10)):
	print(x)   # 打印　9,8,7,6,5,4,3,2,1
>>>sorted((9,3,5,7))  # [3,5,7,9] 

思考：
　　元组能否存入列表？即：
  t=(1,2,[3.1,3.2])

  能否把3.1改为３．１４？
  能
　　t=(1,2,[3.1,3.2])
  t[2]=[8,9] 此示例为错误不能改变元组下标为２的整体元素

  练习：
	任意输入一个字符串，将此字符串中的空格全部去掉，生成反转后的字符串
  如：输入：abc def g 
  打印输出: gfedcda

  (提示：可用反向切片或revered进行反转)


方法一：
s=input("输入字符串:")
s2=s.replace(" ","")
s2=s2[::-1]
print(s2)
方法二：
l=[]
for x in reverde(s):
	if x != " ":
	l.append
 s2="".join(l)
 s2=s2[::-1]
 print(s2)
方法三：
a=s.split()
s2="".join(a)
s2=s2[::-1]
print(s2)


字典　dict
什么是字典：
　　字典是一种可变的容器，可以存储任意类型的数据
　　字典中的每个数据都是用键进行索引的，而不像序列可以用下标(index)来进行索引
字典中的数据没有先后顺序关系，字典的存储是无序的
字典中的数据以键(key)-值(value) 对的形式进行映射存储
字典的键不能重复，且只能用"不可改变类型"作为字典的键


字典的字面值的表示方式：
　字典的表示方式以{}括起来，以冒号(:)分割键-值对，各键-值对之间用逗号(,)分隔开
创建空字典：
　　d={} # d绑定字典
创建非空字典：
d={'name':'tarena','age':16}
d={'year':2018,'month':4,'day':1}


字典的构造函数　dict
  dict() 　生成一个空字典，等同于　{}
  dict(iterable) 用可迭代对象初始化一个字典
  dict(**kwargs) 用命名关键字传参形式生成一个字典
  示例：

  d=dict()
  d=dict([('name','tarena'),('age',15)])
  d=dict(name='tarena',age=15)


字典的键为不可变类型:
bool， int ，float， complex ，str ，tuple， frozet(固定集合)　，bytes(字节串)
包括:None

可变类型(不能充当字典的键)：
list ，dict ，set(集合)，　bytearray(字节数组)

字典的基本操作：
　　键索引：
　　语法：
　　　字典[键]
示例：
>>>d={'name':'tarena','age':15}
>>>d['name']   # 'tarena'
>>>d['age']    # 15

添加/修改字典元素
字典[键]　=指对象
示例：
　d={}
d['birthday']=(2002,1,1)# 添加键值对
d['age']=16 　# 添加键值对
d['age']=17　　# 修改'age'键所对应的值

删除字典元素　del 语句
　　语法：

　　del 字典[键]
示例：
　d={'name':'tarena','age':16}
del d['age'] # 删除'age'这个键




练习：
　　算出　100~999 以内的水仙花数(Narissistic Number)
 水仙花数是值百位的3次方　加上　十位的3次方
 加上个位的3次方等于原数的数字
 例如：
 153=1**3+5**3+3**3
for x in range(100,1000):
	a=x%10#个位值
	b=(x%100)//10#十位值
	c=x//100#百位值
	if x==a**3+b**3+c**3:
	print(x)

方法二：
g=[]
for x in range(100,1000):
	d=str(x)
	a=list(d)
	if x==int(a[0])**3+int(a[1])**3+int(a[2])**3:
		g.append(x) 
print(g)
方法三：
for bai in range(1,10):
	for shi in range(10):
		for ge in range(10):
			x=bai*100+shi*10+ge
			if x==bai**3+shi**3+ge**3:
			print(x)
任意输入一些大于零的数，存于列表中l，当输入-1时结束输入
1)打印出这些数
2)打印出这些数的和
3)去掉列表中重复的数再次存入列表l1中
4)打印l1列表中数据的和
5)将l列表中，出现两次的数存到另一个列表l3中
o=[]
d=[]
iu=[]
er=[]
while True:
	a1=int(input("请输入一个大于零的数(-1 退出):"))
	if a1==-1:
		break
	d.append(a1)
print("这些数为:",d)
print("和为",sum(d))

for a in d:
	if d.count(a)==1:
		o.append(a)
	elif d.count(a)==2:
		er.append(a)
		d.remove(a)
	elif d.count(a) >= 2:
		num=d.count(a)
		iu.append(a)
		i=1
		while i<=num:
			d.remove(a)
			i+=1

print(o)
poi=o+iu    
print(poi)
print(sum(poi))
print(er)
方法二:
l=[]
while True:
	x=int(input("请输入:"))
	if x==-1:
		break
	l.append(x)
print("输入列表为:",l)
print("和为:",sum(l))
l2=[]
for x in l:
	if x not in l2:
		l2.append(x)
pritn(l2)
print("和为:",sum(l2))
l3=[]
for x in l:
	if l.count(x)==2:
		if x not in l3:　#　判断x是否存在与l3中,就不需要删除　x　了
			l3.append(x)

print(l3)



 day 10



字典的成员资格判断  in / not in 运算符
	　只能判断　键是否存在与字典　　不能判断　值是否存在与字典
　　用　in 运算符可以判断一个键是否存在与字典中，如果存在则返回True,否则返回False
  not in　返回值　与in 相反
  示例：
  d={1:"一",2:"二"}
  1 in d     #True
  2 in d     #True
  2 not in d #False
  8 not in d #True
  d in d     #False
  "一" in d  #False 


列表的 in 运算符和字典的　in 运算符比较:

1.列表的in 运算符计算时间会因列表中的元素个数的增加而增加
l=[3,4,5,6,7,....,10976] #大约有十万个
 如：  if 888 in l:
		　　pritn("查看888是否在列表里") 　#　速度慢

2.字典的in 运算符计算时间不会因键值对的个数增加而增加，操作速度快于列表　　　　　　　　　

d={3:"三",7:"dd",0:None,...10976:None}
if 888 in d:
	print("查看888是否在字典里")　　　#　速度快



字典的迭代访问：
　　容积式可迭代对象，字典只能对键进行迭代访问
　　d={"name":"xiaohua","birthday":(2008,8,8),}
  for k in d:
	  print("键",k,"值",d[k]) # 得到键值对 



可用于字典的内键(built-in)函数：
这些函数只对键有作用，对值无作用
len(x)返回字典的键值对的个数
max(x)返回字典的建的最大值
min(x)返回字典的键的最小值
sum(x)返回字典的所有键的和
any(x)对所有键进行真值测试，有一个为True结果为True
all(x)对字典进行真值测试，所有为True才为True

字典的方法：
见：
　　　>>>help(dict)
常用方法：

D代表字典对象  
D.clear() 　　　　　清空字典 
D.pop(key) 　　　　移除键，同时返回此键所对应的值 
D.copy() 　　　　　返回字典D的副本,只复制一层(浅拷贝) 
D.update(D2) 　　　将字典 D2 合并到D中，如果键相同，则此键的值取D2的值作为新值 
D.get(key, default) 返回键key所对应的值,如果没有此键，则返回default 
  
D.keys() 　　　　　返回可迭代的 dict_keys 集合对象
for a in D.keys():
	print(a) 
D.values() 　　　返回可迭代的 dict_values 值对象
 for a in D.values():
	print(a) 
D.items() 　　　　返回可迭代的 dict_items 对象
 
for a in D.items():
	print(a) 


练习：

输入一个字符串代表星期几(0~6)，"0""日"/"周日"，"一"/"1"代表周一以此类推
..."6""六"代表周六
任意输入字符串，打印这个字符串是否代表星期几，如果不是以上字符打印"字典没有相应数据"
(要求将以上数据存于字典，键为字符串"0~6，日~六"的一个，值为星期几)
d={"1":"星期一","2":"星期二","3":"星期三","4":"星期四","0":"星期五","6":"星期六","0":"星期日","一":"星期一","二":"星期二","三":"星期三","四":"星期四","五":"星期五","六":"星期六","日":"星期日"}
a=str(input("输入字符:"))
if a in d:
	print(a)






字典推导式：
作用：
　　用可迭代对象生成字典

语法：
{键表达式：值表达式　for 变量　in 可迭代对象[if 真值表达式]}
注[]的内容可以省略

示例：
　　# 生成一个字典，键为10 以内的数字，值为键的平方
　d={x : x**2 for x in range(10)}



练习：
有字符串列表如下：
　l=["tarena","xiaozhang","hello"]
用推导式生成如下字典：
d==["tarena":6,"xiaozhang":9,"hello":5]
注：字典的长度为键的值
a=["tarena","xiaozhang","hello"]
df={ x : len(x) for x in a }
print(df)

有两个列表：
n=[1001,1002,1003,1004]
name=['tom','jerry','spike','tyke']
生成字典
n=[1001,1002,1003,1004]
name=['tom','jerry','spike','tyke']
asdf={ n[x]:name[x]  for x in range(len(n)) }
print(asdf)


字典推导式的嵌套：
　　语法同列表推导式嵌套


字典 vs 列表
1. 都是可变对象
2．索引方式不同，列表用整数索引，字典用键索引
3．字典的查找速度可能快于列表(重要)
4．列表的存储有序，字典的存储无序



集合　set
  集合是可变的容器
  集合内的数据对象都是唯一的(不能重复多次)
  集合是无序的存储结构，集合中的数据没有先后顺序关系
  集合内的元素必须是不可变对象
  集合是可迭代对象
  集合相当于只有键没有值得字典(键则是集合的数据)
 
 创建空的集合：
  set()

创建非空的集合：
  s={1,2,3,4}


集合的构造函数：　set
set()创建一个空集合对象(不能用{}来创建空集合)
set(iterable) 用可迭代对象创建一个新的集合对象
示例：
s=set()  # 空集合
s={1,2,3,4}
s=set("abc")
s=set({1:'1',2:'2',3:'5'})  # s= {1,2,3}
s=set(range(1:10:3)) # s={1,4,7}

集合的运算：
　　交集，　并集，补集，子集，超集
运算符：
　& | - ^ < <= > >= != ==
  not in  / in  
交集：
& 生成两个集合的交集
s1={1,2,3}
s2={2,3,4}
s1 & s2  # {2,3}
并集：
| 生成两个集合的并集　　
　　s1={1,2,3}
  s2={2,3,4}
  s1 | s2 # {1,2,3,4}
生成属性s1但不属于s2


补集：
- 生成两个集合的补集
　　s1={1,2,3}
  s2={2,3,4}
  s1 - s2   # {1}
^ 生成两个集合的对称补集
　　s1={1,2,3}
  s2={2,3,4}
  s1 ^ s2  # {1,4}

> 判断一个集合是另一个集合的超集
< 判断一个集合是另一个集合的子集
　　{1,2,3} > {1,2}  # True
  {2,3,1} > {3,2}  # True
  {2,3,4} < {1,2,3,4} # True

　> < == != 判断的是数量　

==  ,  !=  集合相同和不同
　{1,2,3} == {3,2,1}  # True
 {1,2,3} != {2,3,4}  # True


in / not in 运算符
　　　等同于字典的in，用于集合中，当某个值存在于集合中返回True,否则返回False

not in 与in 返回值相反

集合的in / not in 运算符的速度快于序列

s1{1,2,3}
1 in s1 # True


能用于集合的函数
len(x)
max(x)
min(x)
any(x)
all(x)
sum(x)

集合的可迭代对象



练习：

　经理有：　曹操，刘备，周瑜
　技术员有：　曹操，周瑜，张飞，赵云
用集合求：
　１．既是经理又是技术员的有谁
２．是经理，但不是技术员的是谁
３．是技术员，但不是经理的都有谁
４．张飞是经理吗
５．身兼一职的都有谁
６．经历和技术员共有几人
jingli={"曹操","刘备","周瑜"}
jishuyuan={"曹操","周瑜","张飞","赵云"}
print(jingli & jishuyuan)
print(jingli-jishuyuan)
print(jishuyuan-jingli)
print("张飞"in jingli) / print( "是"if "张飞"in jingli else "不是") 
print(jishuyuan^jingli)
print( " gonyou%d"  % len(jingli | jishuyuan))


python3 集合中的常用方法:
  见：　
   >>>help(set)
S.add(e) 
在集合中添加一个新的元素e；如果元素已经存在，则不添加 
S.remove(e) 
从集合中删除一个元素，如果元素不存在于集合中，则会产生一个KeyError错误 
S.discard(e) 
从集合S中移除一个元素e; 
S.clear() 
清空集合内的所有元素 
S.copy() 

将集合进行一次浅拷贝 
S.pop() 从集合S中删除一个随机元素;如果此集合为空，则引发KeyError异常 
S.update(s2) 
用 S与s2得到的全集更新变量S 

>>>s1={10000,20000,30000}
>>>s2={30000,40000}
>>>s1.update(s2)
>>>s1  # {30000,10000,20000,40000}

以下内容可以用运算符操作代替  
S.difference(s2) 用S - s2 运算，返回存在于在S中，但不在s2中的所有元素的集合 
S.difference_update(s2) 等同于 S = S - s2 
S.intersection(s2) 等同于S & s2 
S.intersection_update(s2) 等同于S = S & s2 
S.isdisjoint(s2) 如果S与s2交集为空返回True,非空则返回False 
S.issubset(s2) 如果S与s2交集为非空返回True,空则返回False 
S.issuperset(...) 如果S为s2的子集返回True,否则返回False 
S.symmetric_difference(s2) 返回对称补集,等同于 S ^ s2 
S.symmetric_difference_update(s2) 用S 与 s2的对称补集更新 S 
S.union(s2) 生成 S 与 s2的全集


集合推导式
　　集合推导式是用可迭代对象生成集合的表达式
　　可嵌套
语法：
{表达式　for 变量　in 可迭代对象　[if 真值表达式]}
注：　[] 内的内容可省略

示例：
　numbers=(1,2,3,2,2,3,3,4,5)
s={x for x in numbers} # 去除重复的元素 


　　　　　　　　
运算：
& 交集
| 并集
- 补集
^ 对称补集
in / not in
< <= > >= == !=
(以上运算　与set 的运算完全形同)

固定集合的方法：
　　相当于集合的全部方法(去掉修改集合的方法)



* 字典添加，删除，修改是用hash存储

列表，字典，集合对象优缺点：
１．都为可变
２．列表的尾部插入(append)速度比较快，查中间插入和头插数据(index)速度慢
３．列表有序
４．字典添加，删除，修改速度快于列表
５．集合的添加，删除快于列表，且不能存储重复元素

练习：
　１．输入一个字符串，打印所有输入的字符，但重复的值打印一次，(不要求打印顺序与输入顺序一致)
２．输入字符串，打印这个字符串中出现的字符及出现的次数
方法一
a=input("输入字符串:")
b=set(a)
print(" ".join(b)) |for c in b:
				   |    print(c, end=" ")
方法二
a=input("输入字符串:")
l=[]
for x in a:
	if x not in l:
		l.append(x)
print(l)
2.c=input("输入字符串:")
  d=list(c)
  for s in d:
	  print(d.count(s),s)
	  if d.count(s)>=2:
		  num=d.count(s)
		  i=1
		  while num>=i:
			  d.remove(s)
			  i+=1
方法二：
d=input("输入字符串:")
a=set(d)
for x in a:
	print(x,d.count(x))
方法三
#创建空字典，键为字符，值为重复次数
s=input("输入字符串:")
d={}
for c in s:
	#　先判断字典有无c对应的字符，如果存在，将次数加一操作，否则把c添加到字典对应值为１
	if c in d:
		d[c]+=1
	else:
		d[c]=1
print(d)
for k in d:

	print(k,":"d[k],"次")


练习：

１．有一只小猴子，摘了很多桃
第一天吃了全部桃子的一半，感觉不饱又吃了一个
第二天吃了剩下桃子的一半，感觉不饱又吃了一个
....以此类推
到第十天，发现只剩下一个
问第一天摘了多少桃

a=1
for x in range(1,10):
    a=(a+1)*2
print(a)

２．完全数
1+2+3=6(6为完全数)
1,2,3都为6的因数(能被一个数x整除的数为y,则y为x的因数)
1*6=6
2*3=6
完全数是指除本身以外的所有的因数之和相加等于自身的数
求4~5个完全数，并打印出来
6  28  496  8128


for x in range(1,100000):
    l=[]
    for a in range(1,x):
        if x%a==0:
            l.append(a)
    if x == sum(l):
        print(x)
方法二
x=1
while True:
    sum_yinshu=0
    for i in range(1,x):
        if s%i==0:
            sum_yinshu +=i
    if sum_yinshu==x:
        print(x,"是完全数")

    i+=1
3.任意输入一个n代表三角形的高度，打印此形状的三角形
如：输入：4
打印如下:
   1
  121
 12321
1234321 

a=int(input("请输入:"))
l=[]
for i in range(1,a+1):
    l.append(i)
    print((a-i)*' ',end='')
    for x in l: 
        print(str(x),end="")
    for d in l[-2: :-1]:
        print(d,end="")
    print()
4.将第三题打印三角形变为打印菱形

a=int(input("请输入:"))
l=[]
for i in range(1,a+1):
    l.append(i)
    print((a-i)*' ',end='')
    for x in l: 
        print(str(x),end="")
    for d in l[-2: :-1]:
        print(d,end="")
    print()
ds=1
while ds<a:
    l.pop()
    print((ds)*" ",end="")
    for r in l:
        print(r,end="")
    for o in l[-2::-1]:
        print(o,end="")
    print()
    ds+=1


day 11

函数　function

什么是函数：
　　函数是重复执行的语句块，可以重复调用
作用：
１．用于可重复执行的语句，提高语句的可重用性
２．定义用户级别的函数
如：
　len(x)  max(x)  min(x) ...

函数定义语句　　def语句的语法：
　　def 函数名(参数列表)
　　　　　　语句块(代码块)

函数的语法说明：
１．函数的名字就是语句块的名称
２．函数名的命名规则与变量名命名规则相同(必须为标识符)
３．函数名是一个变量(不要轻易对其赋值)
４．函数有自己的命名空间，在函数内部可以访问外部的变量　　但外部的语句不能访问函数内部的变量
５．函数如果不需要传入参数，则参数列表可以为空
６．语句部分不能为空，如果为空需要填充pass语句

示例:
def say_hello():
    print("hello world")
    print("hello tarena")
    print("hello everyone")
say_hello()
 函数的调用：
 函数名(实际调用传递参数)
 注：
 　　实际调用传递参数　简称"实参"
 调用说明：
 １．函数调用是一个表达式
 ２．如果没有return语句，函数执行完毕后返回None对象
 ３．如果函数需要返回其他对象，需要用到return语句

 示例：
 # 带有参数的函数的定义

 def mymax(a,b):[括号里的是形参变量]  #　此时例定义一个带有参数的函数
 　　　　if a>b:
         print("最大的数是:",a)
     else:
         print("最大的数是:",b)

mymax(100,200) #调用带有参数的函数，第一个实参100给a,第二个实参200给b


mymax(10000,5000)

mymax(4+3,1+2)


练习：
1.写一个函数mysum,此函数带有两个参数x,y
此函数能打印两个参数的和
2.写一个函数　传入一个实参n代表终止整数(不包含n)
打印：
　　2,4,6,...n之间的偶数

def mysum(x, y):
    print(x + y)


mysum(10, 20)

def print_even(n):
    for s in range(n):
        if s % 2 != 0:
            continue
        else:
            print(s,end=" ")
    print()


print_even(10)


函数内部有独立运行的空间，函数外部不能访问函数内的变量

示例：
def test():
　　　　x=100   #此变量是局部变量，只能在函数内部使用

  　　print(y) # 这是合法的，此函数可以访问函数以外的全局变量

y=200
test()　# 调用　test

print(x) # 此时没有x这个变量　　　test中的x是自己的独立运行空间,会报错，打印不出x



return　语句
语法：
　　return[表达式]
　　注：[]代表其中的内容可以省略
作用：
　　用于函数中，结束当前函数的执行，返回调用函数的地方，同时返回一个对象的引用关系
说明：
１．return语句后跟的表达式可以省略，省略后相当于return　None
２．如果函数没有return语句，则函数执行完最后一条语句后返回None(相当于在最后加了一条return None语句)
３．函数调用能够返回一个对象的引用关系
示例：
#此示例示意return语句的用法
def hello():
    print("hello aaa")
    print("hello bbb")
    return # 用于返回到调用的地方
    print("hello ccc")

v=hello()
print(v)


练习
１．写一个函数mymax，返回两个数的最大值
如：
　　def mymax(a,b):
   ...
   print(mymax(100,200))#200
   print(mymax("acd","abcd"))#acd

def mymax(a,b):
    return max(a,b)

print(mymax(100,20))
print(mymax("acd","abcd"))


２．写一个函数input_number()此函数用于读取用户输入的多个整数(用户输入负数时结束输入)将用户输入的数形成列表返回给调用者
　　def  input_number():
   ...  
   l=input_number()
   print("您输入的最大数是："max(l))
   print("您输入的这些数的和是："sum(l))

def mymax(a,b):
    if a>b:
        s=a
    else:
        s=b
    
    return s

print(mymax(10,20))
print(mymax("acd","abcd"))
方法二：
def mymax(a,b):
    if a>b:
        return a
    return b
print(mymax(10,20))
print(mymax("acd","abcd"))

def input_number():
    s=[]   # 临时列表，用于存储数据
    while True:
        a=int(input("输入数:"))
        s.append(a)
        if a<0:
            break
        s.append(a) 
    return s 

l=input_number()
print(sum(l))
print(max(l))
方法二：
def input_number():
    s=[]   
    while True:
        a=int(input("输入数:"))
        s.append(a)
        if a<0:
        　　　　return s
        s.append(a) 
    

l=input_number()
print(sum(l))
print(max(l))



python函数的参数传递
  传递方式：
　　　　位置传参
　　　　序列传参
　　　　关键字传参

　　位置传参：
    实际调用参数(实参)的对应关系与形式参数(形参)的对应关系是按照位置来依次对应的
  示意：
  　　def fx(a,b,c):
        pass
    fx(1,2,3)

  序列传参：
  　　序列传参是指在函数调用的过程中，用*将序列拆解后按顺序位置进行传递的传参方式
  　　实参和形式通过序列传递和匹配
  示例：
  def fx(a,b,c):
      print("a=",a)
      print("b=",b)
      print("c=",c)

  s1=[11,22,33]
  fx(*s1)   # 一个星号后跟一个序列 将s1序列拆解后按位置传入fx
  fx(*"abc")
  fx(*(1,2,3))


  关键字传参：
  　　是指传参时，按着形参的名称给形参赋值
  　　是参合形参按名称机型匹配
  示例：
  def fx(a,b,c):
      pass


  fx(b=22,c=33,a=11)  #　11 ->a 22 ->b 33 ->c
  注：
  　　实参和形参按形参名进行匹配，可以不按位置进行匹配
  字典关键字传参：
  　　实参为字典，用**拆解字典后在进行关键字传参
  示例：
　　def fx(a,b,c):
      pass
  d={"c":33,"b":22，"a":11}
  fx(**d)  # 拆解字内再依次按关键字传参
  说明：
  字典的键名和形参必须一致
  字典的键名必须为字符串
  字典的键名要在形参中存在



  综合传参：
  　　函数的传参方式在能确定形参能唯一匹配到相应实参的情况下可以任意组合
  注：
  　通常位置传参和序列传参先传递，其次是关键字传参和字典关键字传参
  示例：
  def fx(a,b,c,d,e,f):
      pass

  fx(10,*[20,30],e=50,**{"d":40,"f":60})
  #　以下是错误做法
  fx(e=50,**{"d":40,"f":60},10,*[20,30])

 ##################以下将函数的形参##############

函数的缺省参数：
　　语法：
　　　　def 函数名(形参名1=默认实参1,形参2=默认实参2,...):
        语句

  示例：
  def info(name,age=1,address="不详"):
      print("我叫",name,"我今年",age,"岁,家庭地址:",address)


  info("张飞",30,"中原")
  info("Tarena",10)
  info("赵云")
 说明：
 　　缺省参数必须自右至左依次存在
 　　缺省参数可以有零个，一个，多个，甚至全部都有缺省参数
 　　缺省参数的绑定对象存在于函数内，同函数的生命周期一致
 示例：
 def fn(a,lst=[]):
     lst.append(a)
     print(lst)

 l=[1,2,3,4]
 fn(5,l) #[1,2,3,4,5]
 fn(6,l) #[1,2,3,4,5,6]

 fn(1.1) #[1.1]
 fn(2.2) #[1.1,2.2]

函数的形参定义方式：
１．位置形参
２．星号元组形参
３．命名关键字形参
４．双星号形参


位置形参：
　　def 函数名(形参1,形参２,...):
      语句块


星号元组传参：
　　语法：
　　　　def 函数名(*元组形参名)
　　　　　　　　语句块

　　作用：
　　　　收集多余位置形参,转化成元祖
　　示例：
　　此示例示意星号元组形参
　　def func(*args):
      print("实参个数是:",len(args))
      print("args的值是:",args)


  func(1,2,3) #(1, 2, 3)
  func("abc",4,5,True,None)



命名关键字形参：
　　语法：
　　　　def 函数名(*,命名关键字形参):
        语句块
    或
    def 函数名(*args,命名关键字形参):
        语句块
  作用：
  　　所有的命名关键字形参都强制调用者采用关键字传参或字典关键字传参的方式传递
  示例：
　　def myfun(a,*,k):　　　#有两个形参
      print("a=",a)
      print("k=",k)

  myfun(100,200) #错
  myfun(100,k=200) # k　强制是用关键字传参
  myfun(10,**{"k":20})

  def myfun2(b,*args,c,d):
      print("b=",b)
      print("args=",args)
      print("c=",c)
      print("d=",d)

  myfun2(100,200,300,400) #　错
  myfun2(100,200,300,400,d=600,c=500)


双星号字典形参：
　　语法：
　　　　def 函数名(**字典形参名):
        语句块


  作用：
  　　收集多余的关键字,转化为字典
  注：
    字典形参通常叫kwargs
  示例：
  此示例示意双星号字典形参的用法：
  def func(**kwargs):
      print("关键字传参的个数是:",len(kwargs))
      print("kwargs=",kwargs)


  func(name="tarena",age=15)
  func(a=1,b="BBBB",c=[2,3,4],d=True)


函数参数说明：
　　位置形参，缺省参数，双星号元组形参，命名关键字形参，双星号字典形参可以混合使用

函数参数自左至右的顺序为：
１．位置形参
２．星号元组形参
３．命名关键字形参
４．双星号字典形参
示例：
　　def  fn(a,b,*args,c,**kwargs):
      print(a,b,args,c,kwargs)


  fn(100,200,400,*"AB",**{'d':"D"},c=1000)
  fn(100,200,400,*"AB",**{'d':"D",'c':"C"},e=1000)


可以接受任意位置传参和关键字传参的函数：
def fn(*args,**kwargs):
    pass






练习：
１．写一个函数，mysum,可以传入任意个实参的数字，返回所有实参的和

def mysum():
...

print(mysum(1,2,3,4))
print(mysum(5,6,7,8,9))

def mysum(*age):
    return sum(mysum)

print(mysum(1,2,3,4))
print(mysum(5,6,7,8,9))

2.已知内建函数　max的帮助文档为：
max(...)
   max(iterable)->value
   max(arg1,arg2,*arg3)->value

   仿造max ,写一个mymax函数实现功能与max完全相同
   测试用例：
   print(mymax([6,8,3,5]))#8
   print(mymax(100,200))
   print(mymax(1,3,9,7,5))

def mymax(*args):
    if len(args)==1:
        l=list(*args)
        l.sort(reverse=True)
        return l[0]
    elif len(args)>1:
        l=list(args)
        l.sort(reverse=True)
        return l[0]
print(mymax([6,8,3,5]))
print(mymax(100,200))
print(mymax(1,3,9,7,5))
方法二：
def mymax(a,*args):
    if len(args)==0:
        m=a[0]
        i=1
        while i <len(a): # 遍历之后的每一个元素
        if a[i] > m: # 如果此元素比m大，则让m绑定大的
            m=a[i]
         i+=1   
        return m
    else :
        m=a
        for x in args:
            if x>m:
                m=x
        return m

print(mymax([6,8,3,5]))
print(mymax(100,200))
print(mymax(1,3,9,7,5))

改进：

def mymax(a,*args):
　　　　def _max(*args):# 此函数用于求args的最大值
        m=args[0]
        i=1
        while i <len(args): # 遍历之后的每一个元素
        if args[i] > m: # 如果此元素比m大，则让m绑定大的
            m=args[i]
         i+=1   
        return m
    if len(args)==0:
        return _max(*a)

    return _max(a,*args)
  

print(mymax([6,8,3,5]))#8
print(mymax(100,200))
print(mymax(1,3,9,7,5))


３．写一个函数minmax,可以给出任意个数字实参，返回这些实参的最大数和最小数，要求两个数字形成元组后返回(最小数在前，最大数在后)调用此函数，能得到实参的最小值和最大值
def minmax(...):

xiao,da=minmax(5,7,9,3,1)
print("最小数是:",xiao)
print("最大数是",da)

def minmax(*args):
    return (min(args),max(args))

xiao,da=minmax(5,7,9,3,1)
print("最小数是:",xiao)
print("最大数是",da)

day 12

函数变量：
　　函数名是变量，它在创建时绑定一个函数
示例：
def f1(lst=[]):
    print("f1函数被调用")
f1()
f1=None
f1()　# 出错

如果　del f1 这个函数则被释放，没有变量绑定函数

def f1():
    print("hello")
def f2():
    print("world")

f1,f2=f2,f1
f1()  # world

一个函数可以作为另一个函数的参数(实参)传递
示例:
def f1():　　　# f1=函数f1
    print("f1函数被调用")
def f2():  # f2=函数f2
    print("f2函数被调用")

def fx(fn):  # fn=函数fn
    print("fn绑定的函数是:",fn)
    # 在fx内调用fn绑定的函数
    fn()

fx(f1) # 调用fx,把f1作为实参传数
fx(f2) # 用fx间接调用 f2

fx(f1()) # 这样会报错，默认为f1返回的是None,fn(None)会报错

看懂下列代码在做什么？为什么？
def goodbye(l):
    for x in l:
        print("再见",x)
def hello(l):
    for x in l:
        print("欢迎:",x)
def fx(fn,l):
    print("fx被调用")
    fn(l)
fx(hello,['Tom','Jerry','Spike'])
fx(goodbye,['小张','小李'])
打印内容：

fx被调用
欢迎: Tom
欢迎: Jerry
欢迎: Spike
fx被调用
再见 小张
再见 小李

函数可以作为另一个函数的返回值：
函数可以返回另一个函数
示例：
def get_op():
    s=input("请输入您的操作:")
    if s=="求最大":
        return max
    elif s=="求最小":
        return min
    elif s=="求和":
        return sum

l=[2,4,6,8,10]
print(l)
f=get_op()
print(f(l))

函数嵌套定义：
　　def 语句的作用是用来创建一个函数
　　def 语句可以写在函数内部，在函数执行时可以动态创建一个函数
示例：
def get_func(value):
    if value ==1:
        def myadd(x,y):
            return x+y
        return myadd
    elif value ==2:
        def mysub(x,y):
            return x-y
        return mysub
fx=get_func(1)
print(fx(400,300))
fx=get_func(2)
print(fx(400,300))

全局变量和局部变量：
　　局部变量：
　　　　定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
    局部变量只能在函数内部使用
    局部变量在函数调用时才能够被创建，在函数调用之后会自动销毁
  全局变量：
  　　定义在函数外部，模块内部的变量成为全局变量
  　　全局变量，所有函数都可以直接访问(但函数内部不能直接修改全局变量的绑定关系)

示例：
a=100
b=200
def fn(c):
    d=400
    print(a,b,c,d)

fn(300)
print('a=',a)
print('b=',b)
print('c=',c)#　函数调用完被销毁掉，不会有c



局部变量说明：
１．在函数内首次对变量复制时创建局部变量，再次为变量赋值是修改局部变量的绑定关系
２．在函数内部的赋值语句不会对全局变量造成影响


python作用域
　　作用域也叫命名空间，是访问变量时查找变量名的范围空间


python的四个作用域LEGB

作用域　　　　　　　　　　　　　　　　　　　英文解释                 英文简写
局部作用域　(函数内)　　　　　　　Local(function)　　　　　　　　　　  L
外部嵌套函数作用域  Enclosing function locals        E
函数定于所在模块的作用域  Global(module)              G
python内置模块的作用域   Builtin(python)             B

示例：
v=100
def fun1():

    v=200
    print("fun1里的v的值为:",v)   # 200
    # 定义另一个函数fun2然后调用
    def fun2():
        print("fun2v=",v)   # 200
    fun2()

fun1()
print("全局变量v=",v)

变量名的查找规则(顺序)：
１．查找本地变量
２．查找包裹此函数的外部嵌套函数内部的变量
３．全局变量
４．内置变量

globals() / locals() 函数
　　globals() 返回全局作用域内变量的字典
　　locals() 返回局部作用域内变量的字典

示例：
a=100
b=200
def fx(b,c):
    print(a,b,c)
    # 思考在此函数内部能否获取到全局变量b绑定的值?   不能
   
    print("全局变量的字典是:",globals())
    print("局部变量的字典是:",locals())
    print("此处访问全局的b的值是:",globals()['b'])
fx(300,400)  # (100,300,400)
#打印为：
100 300 400
全局变量的字典是: {'__name__': '__main__', 'b': 200, '__file__': 'wh.py', '__spec__': None, '__package__': None, 'fx': <function fx at 0x7f6751369f28>, '__cached__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f67512ab9e8>, 'a': 100, '__builtins__': <module 'builtins' (built-in)>, '__doc__': None}
局部变量的字典是: {'b': 300, 'c': 400}
此处访问全局的b的值是: 200

练习：
写一个函数mysum 此函数的功能是能返回：
1+2+3+4+5+6+...+n的和

def mysum(n):
.....
print(mysum(100))

写一个函数mysum2 此函数可以传入一个参数，两个参数和三个参数：
１．当传入一个参数是，这个参数代表终止数
２．当传入两个参数时，第一个参数代表起始值，第二个参数代表终止值
３．当传入三个参数时，第三参数代表步长此功能是返回从开始到终止值的和
如：
print(mysum2(5)) # 10 (0+1+2+3+4)
print(mysum(4,6)) # 9 (4+5)
print(mysum(5,10,2))  # 21 (5+7+9)

1.
 def mysum(n):
   
    d=[]
    for i in range(1,n+1):
        d.append(i)
    return sum(d)


print(mysum(100))

2.
def mysum2(*age):
    if len(age)==1:
        s=0
        for x in range(age[0]):
            s+=x
        return s
    elif len(age)==2:
        s=0
        for x in range(age[0],age[1]):
            s+=x
        return s
    elif len(age)==3:
        s=0
        for x in range(age[0],age[1],age[2]):
            s+=x
        return s
  
print(mysum2(5))
print(mysum2(4,6))
print(mysum2(5,10,2))

方法二
def mysum2(a,b=0,c=1):
    if b is 0 :
        b=a
        a=0
    s=0
    for x in range(a,b,c):
        s+=x
    return s
print(mysum2(5))
print(mysum2(4,6))
print(mysum2(5,10,2))

方法三
def mysum2(a,b=0,c=1):
    if b is 0 :
        b=a
        a=0
    return sum(range(a,b,c))
  
print(mysum2(5))
print(mysum2(4,6))
print(mysum2(5,10,2))

方法四：
def mysum2(*arges):
    return sum(range(*arges))


print(mysum2(5))
print(mysum2(4,6))
print(mysum2(5,10,2))

global 语句：
　　作用：
　　１．告诉解释执行器，global语句声明的一个或多个变量，这些变量的作用域为模板级的作用域的变量，也称全局变量
　　２．全局声明(global)
　　　　将赋值变量映射到模块文件内部的作用域

　　语法：
　　global 变量1, 变量2,...
  示例：
  global 　ga ,gb
  global gc


  
global 声明示例：
v=100
def fx():
    global v 　#　　声明v为全局变量，不是局部变量

    v=200

fx()
print(v)   # 100　　　　加上global语句后，结果为　# 200

说明：
１．全局变量如果要在函数内部被赋值，则必须经过全局声明(否则会被认为局部变量)
２．全局变量在函数内部不经过声明就可以直接访问
３．不能先声明局部变量，再用global声明为全局变量，此做法不符合规则
    如       v=200
             global v　　(不能这样写)
４．global变量列表里的变量名不能在此作用域内的形参列表里
　　如： def f1():
          print(v)

      f1(300)  [此时不能加global语句，来声明v是全局变量]


nonlocal语句：
　　作用：
　　　　告诉解释执行器，nonlocal声明的变量不是局部变量，也不是全局变量，而是外部嵌套函数内的变量
　　语法：
　　nonlocal  变量名1, 变量名2,...
　　示例：
　　v=100
  def outter():
      v=200
      print("outter里的v=",v)
      def inner():
          nonlocal v
          v+=1
          print("innter里的v=",v)

      inner()
      print("调用inner后,ouuter里的v=",v)

  outter()
  print("全局变量的v的值是:",v)



说明：
１．nonlocal 语句只能在被嵌套函数内部进行使用
２．访问nonlocal变量将对外部嵌套函数作用域内的变量进行操作
３．当有两层或两层以上函数嵌套时，访问nonlocal变量只对最近一层的变量进行操作
４．nonlcal语句的变量列表的变量名不能出现在此函数的参数列表里

说明示例：
def f1():
    v=100
    def f2():
        v=200
        def f3():
            nonlocal v
            v+=1  # 此时只对f2的v 进行操作
　　　　　　　　f3()
    f2()



练习：
１．创建一个列表l=[]
写一个函数 input_number 读取数据放入列表l中
程序如下：
l=[]
def input_number():
    此处代码自己打
    while True:
        i=int(input("请输入数字(-1结束):"))
        ...
        此处代码自己打
input_number()
答案：

l=[]
def input_number():
    s=[]
    while True:
        i=int(input("请输入数字(-1结束):"))
        if i==-1:
            break
        s.append(i)
    global l
    l=s

input_number()
print("您刚才输入的整数值是:",l)


２．写一个函数isprime(x)判断x　是否为素数，如果为素数True,否则返回False
测试代码
if isprime(5):
    print("是素数")

　def isprime(x):
    if x<=1:　　　#　排除小于1的数
        return False
    for i in range(2,x):
        if x%i==0:
            return False
    return True
if isprime(5)
    print("5是素数")

３．写一个函数prime_m2n(m,n)返回从m开始，到n结束范围内的列表，并打印
l=prime_m2n(10,20)
print(l) #[11,13,17,19]

def prime_m2n(m,n):
    return list(filter(isprime,range(m,n)))

l=prime_m2n(10,20)
print(l) 


４．写一个函数primes(n),返回小于n的所有的素数的列表
l=primes(10)
print(l) #[2,3,5,7]

def primes(n):
    return prime_m2n(2,n)


l=primes(10)
print(l)




day 13

lambda 表达式(又名匿名函数表达式)
　　作用：
　　　　创建一个匿名函数对象
　　　　同def类似，但不提供函数名
　　语法：
　　　　lambda [形参1,形参2,...]:表达式

　　语法示例：

  def mymax(x,y):
      return x+y
  可以改写为：
  myadd=lambda x,y:x+y

  示例：
  >>>myadd=lambda x,y: x+y
　　>>>print(myadd(1,2))  # 3
  >>>print(myadd("123","abc")) #  123abc
  
  语法说明：
  １．lambda 只是一个表达式，它是用来创建一个函数对象
  ２．当lambda表达式调用时，先执行冒号后的表达式，并返回表达式的结果的引用
  ３．lambda表达式创建的函数只能包含一条表达式
  ４．lambda比函数简单，且可以随时创建和销毁，有利于减少程序的偶合度

练习：
写一个lambda表达式，判断这个数2次方加一能否被5整除，如果能被整除返回True,否则返回False


fx=lambda n : (n**2+1)%5==0 
print(fx(3))

写一个表达式求两个变量的最大值和最小值
mymax=lambda x,y: x if x>y else y
print(mymax(1,2))


看懂下面的程序在做什么：
def fx(f,x,y):
    r=f(x,y)
    print(r)

fx((lambda a,b: a+b),100,200)
fx((lambda x,y: x**y),3,4)


eval 和exec函数
eval函数：
　　作用：
　　　　把一个字符串当成一个函数表达式执行，返回表达式执行后的结果
　　格式：
　　　　eval(source[字符串],globals[全局变量]=None,locals[局部变量]=None)
  示例：
  x=100
  y=200
  s="x+y"
  v=eval(s)
  print(v)
  print(eval("x+y",{'x':10,'y':20})) # 30
  print(eval("x+y",{'x':10,'y':20},{'x':1,'y':2})) # 3
  print(eval("x+y",{'x':10,'y':20},{'x':1})) # 21
exec函数：
　　作用：
　　　　把一个字符串当成程序来执行
　　格式：
　　　　exec(source,globals=None,local=None)
　　示例：
　　　　s='x=100; print("hello"); x+=1; print(x)'
    print(s) # x=100; print("hello"); x+=1; print(x)　
    exec(s) # hello 101
    自己写一个程序，解释执行用户输入的任何语句
    g={}
    l={}
    while True:
        s=input("请输入语句$>>>")
        if s=="bye":
            break
        evec(s,g,l)
    print(g)
    print(l)

函数式编程：
　　是指用一系列函数解决问题

函数是一等公民
　　函数本身是对象，可以赋值给变量，赋值后变量绑定函数
　　允许将函数作为实参传入另一个函数
　　允许函数返回一个函数

函数式编程的好处：
１．每一个函数完成细小的功能，一系列函数的任意组合可以解决大的问题
２．函数仅接受输入并产生输入，不会影响其他全局变量的状态
思考：
求1+2+3+...+n的和
print(sum(range(n+1)))


练习：
求1+1/2+1/4+1/8+...1/2**n

n=100
print(sum([1/2**x for x in range(n+1)]))

高阶函数：High Order Function
　　什么是高阶函数：
　　　　满足下列条件中的一个条件即为高阶函数
　　　　1.函数接受一个或多个函数作为参数传入
　　　　2.函数返回一个函数
python内置(bultins)的高阶函数：
  map ,filter, sorted
map函数：(挨个计算并返回结果)
　　map(func(函数),*iterables[])[*iterable是可变参数]用函数对可迭代对象中的每一个元素作为参数计算新的可迭代对象，当最短的一个可迭代对象不在提供数据时，此迭代对象生成结束 

示例：
　　生成一个可迭代对象，要求可迭代对象可以生成1~9自然数的平方
def power2(x):
    return x**2
for x in map(power2,range(1,10)):
    print(x)
求以上数据的和
print(sum(map(power2,range(1,10))))

示例：
生成一个可迭代对象，要求此可迭代对象生成
1**4  2**3  3**2  4**1

for x map(pow,[1,2,3,4],[4,3,2,1])
    print(x)


练习：
求　1**2 +2**2+3**2...9**2的和
求　1**3 +2**3+3**3...9**3的和
求　1**9 +2**8+3**7...9**1的和
方法一
print(sum(map(lambda x: x**3,range(1,10))))
方法二
def yui(x):
    return x**3

print(sum(map(yui,range(1,10))))

3.
print(sum(map(pow,range(1,10),range(9,0,-1)))) 


filter函数：(挨个计算，进行筛选并返回来)
　　格式：
　　　　filter(func,iterable)[iterable是位置参数]
  作用：
  　　筛选可迭代对象iterable中的数据，返回一个可迭代对象，此可迭代对象将对iterable进行筛选
  　　函数func将对iterable中的每个元素进行求值，返回False时将此数据丢弃，返回True,则保留此数据
  示例：
  # isodd函数判断x是否为奇数，是奇数返回True
  def isodd(x):
      return x%2==1

打印10以内的奇数：
def isodd(x):
      return x%2==1
for x in filter(isodd,range(10))
    print(x)

生成10以内所有偶数的列表，用filter实现
def isodd(x):
      return x%2==0
d=[x for x in filter(isodd,range(10))]
print(d)
方法二：
l=[x for x in filter(lambda x: x%2==0,range(10))]
print(l)



sorted　函数
作用:
　　将原可迭代对象的数据进行排序，生成排序后的列表
格式：
  sorted(iterable,key=None,reverse=False)
参数说明：
　　iterable　可迭代对象
　　key 绑定函数，此函数用来提供一个排序的依据
　　reverse　标志用来设置是否降序排序(从大到小)
示例：
l=[5,-2,-4,0,3,1]
l2=sorted(l)     # l2=[-4,-2,0,1,3,5]
l3=sorted(l,reverse=True)  # l3=[5,3,1,0,-2,-4]
l4=sorted(l,key=abs)  # [0,1,-2,3,-4,5]

按照名字长度排序：

names=['Tom','Jerry','Spike','Tyke']
l=sorted(names)
a=sorted(l,key=len)
print(a)
名字反过来排序
names=['Tom','Jerry','Spike','Tyke']
def df(x):
    return x[::-1]
l=sorted(names,key=df)
print(l)

递归函数　recursion
  函数直接或间接的调用自身

函数直接调用自身的示例：
def f():
    f() #调用自己
f()
print("递归完成")

函数间接调用自身的示例：
def fa():
    fb()

def fb():
    fa()
fa()

递归说明：
　　递归一定要控制递归的层数，当符合某一条件是要终止递归，几乎所有的递归都能用循环来代替

递归的优缺点：
优点：
　　递归可以把问题简单化，让路径更为清晰，代码更为简洁
缺点：
　　递归因系统环境的影响大，当递归深度太大时，可能会得到不可预知的结果

示例：
此程序用来示意递归函数的调用
以下程序会无限递归，永不终止
def story():
    print("从前有座山，山上有座庙，庙里有个老和尚讲故事:")
    story()
    print("故事讲完了")
story()
此程序用来示意递归函数的调用
此程序用参数来控制最大次数为3
def story(times):
    print("第",times"遍")
    print("从前有座山，山上有座庙，庙里有个老和尚讲故事:")
    if times>=3:
        return 
    story(times+1)
    print("故事讲完了")
story(1)

递归函数的实现方法：
　　先假设函数已经实现

示例：
求100+99+98+97+...+1的和
分析：
　　先假设mysum(x)　已经完成且能求x+(x-1)+...+1的和
def mysum(x):
    #　判断终止条件
    if x==1:#定义一个出口，当x=1时，返回1的值，是一个判断条件
        return 1
    return x + mysum(x-1)
print(mysum(100))




练习：
１．编写函数，myfac(x)计算x的阶乘　x!
def myfac(x)
    s=1
    for i in range(1,x+1):
        s=s*i
    return s
myfac(5)
方法二：
def myfac(x):
    if x==1:
        return 1
    return x*myfac(x-1)
myfac(5)
2.写一个程序算出1~20的阶乘的和
思考能否用函数式编程中的高阶函数实现
def myfac(x):
    if x==1:
        return 1
    return x*myfac(x-1)

def mysum(n):
    s=0
    for i in range(1,n+1):
        s+=myfac(i)
    return s
print(mysum(20))
方法二：

def myfac(x):
    if x==1:
        return 1
    return x*myfac(x-1)

def mysum(n):
    return sum(map(myfac,range(1,n+1)))

print(mysum(20))

３．已知有列表:
l=[[3,5,8],10,[[13,14],15],18]
写一个函数print_list(lst)打印出列表中所有数字
print_list(l)
写一个函数sum_list(lst)返回列表中所有数字的和
print(sum_list(l))
注：type(x)可以返回容器类型
如：　>>>type(20)  is int #True

1.
l=[[3,5,8],10,[[13,14],15],18]

def print_list(lst):
    for x in lst:
        if type(x) is list:
            print_list(x)
        else:
            print(x)

print_list(l)
2.
def sum_list(lst):
    s=0
    for x in lst:
        if type(x) is list:
            s+=sum_list(x)
        else:
           s+=x
    return s
print_list(l)
print(sum_list(l))

项目：
开始学生信息管理项目
需要两个函数：　input_student()返回学生信息的字典列表
　　　　　　　　　　　　　output_student(lst) 　以表格的方式打印学生信息
学生信息：
姓名(name)　字符串
年龄(age)　整数
成绩(score)　整数

input_stuent()调用时等待用户输入学生信息，当输入姓名为空时结束输入，最后学生信息形成字典后存入列表中返回
def input_student():
   ...

l=input_student()
请输入学生姓名：xiaozhang
请输入学生年龄：20
请输入学生成绩：98
请输入学生姓名：xiaoli
请输入学生年龄：23
请输入学生成绩：90
请输入学生姓名：<回车>结束
此时列表数据为：
l=[{'name':'xiaozhang','age':20,'score':98},{'name':'xiaoli','age':23,'score':90}]

def output_student(lst):
  ...


print(l) # 打印出字典列表
output_student(l) # 打印出学生信息的表格如下：
+----------+---------+-----------+
|  name    | age     |   score   |
+----------+---------+-----------+
| xiaozhang|    20   |    98     |
| xiaoli   |    23   |    90     |
+----------+---------+-----------+

def input_student():
    lst=[] # 创建一个空列表用于存储学生的信息
    while True:
        n=input("请输入学生姓名:")
        if not n:
            break
        a=int(input("请输入学生年龄:"))
        s=int(input("请输入学生成绩:"))
        # 创建一个字典
        d={'name':n,'age':a,'score':s}
        lst.append(d)# 把字典放到列表
    return lst

def output_student():
    print("+----------+---------+-----------+")
    print("|   name   |    age  |   score   |")
    print("+----------+---------+-----------+")
    for d in lst:
        info="| %9s | %6d | %7d |"%(d['name'],d['age'],d['score'])
        print(info)
        print("+----------+---------+-----------+")

day 14

闭包　closure
  将内嵌函数的语句和这些语句的执行环境打包在一起后，得到的函数对象称为闭包(closure)
闭包必须满足以下三个条件：
１．必须有一个内嵌函数
２．内嵌函数必须引用外部函数中的变量
３．外部函数返回值必须是内嵌函数
示例：
此程序示意闭包用法
１．fn为内嵌函数
２．fn用到了fn外部的变量y
３．make_power将fn绑定的函数对象返回给调用者
def make_power(y):

    def fn(x):
        return x**y
    return fn

pow2=make_power(2)
pow2等同于：
def pow2(x)
    return x**2
print("5的平方是:",pow2(5))
pow4=make_power(4)
print("5的四次方是",pow2(5))
说明
如果一个内嵌函数访问了外部嵌套函数作用域内的变量，则这个内嵌函数就是闭包

装饰器　　decorators(专业提高篇)
　　什么是装饰器
　　　　装饰器是一个函数，这函数的主要作用是包装另一个函数或类
    包装的目的是在不改变原函数名的情况下改变被包装对象的行为

函数装饰器　　function decorators
  函数装饰器是指装饰器是一个函数，传入的是一个函数，返回的也是一个函数


如果一个函数同时被两个或两个以上的装饰器装饰,根据顺序来决定执行顺序，依上而下执行

示例：
def mydeco(fn):  # 装饰函数
    def fx():
        print("hello world")
    return fx
@mydeco
def hello():　　# 被装饰函数
    print("hello tarena")

hello=mydeco(hello)　此时将hello变量绑定在mydeco返回的函数上
                    此种做法可以用装饰器@语法解决
hello() # 调用者
示例：

def mydeco(fn):  # 装饰函数
    def fx():
        print("+++++++")
        fn()
        print("--------")
    return fx
@mydeco
def hello():　　# 被装饰函数
    print("hello tarena")

hello() # 调用者

示例应用：
存钱的函数
# 以下是一个装饰器函数，在fn调用之前加一个权限验证功能
def priv_sheck(fn):
    def fx(name,x):
        print("正在权限验证...")
        fn(name,x)
    return fx
@priv_sheck
def save_money(name,x):
    print(name,"存钱",x,"元")
@priv_sheck
def withdraw(name,x):
    print(name,"正在办理取钱",x,"元的业务")

save_money("小张",200)
save_money("小李",500)
withdraw("小赵",300)

# 示例一个函数可以用两个或两个以上装饰器

def message_send(fn):
    def fy(name,x):
        # 先办业务
        fn(name,x)
        print("短信:",name,"发生了",x,"元的操作,余额是xxx")
    return fy

def priv_sheck(fn):
    def fx(name,x):
        print("正在权限验证...")
        fn(name,x)
    return fx
@priv_sheck
def save_money(name,x):
    print(name,"存钱",x,"元")

@message_send(后调用的装饰器放在上面)
@priv_sheck
def withdraw(name,x):
    print(name,"正在办理取钱",x,"元的业务")

save_money("小张",200)
save_money("小李",500)
withdraw("小赵",300)

函数的文档的字符串：
　　语法：
　　def 函数名(参数列表)：
　　　　　　"""函数的文档字符串"""
      函数语句块
  说明：
  文档字符串通常来用说明本函数的功能和使用方法
  在交互模式下，输入help(函数名)
  可以查看函数的"文档字符串"
示例：
def my(a,b):
    "这是一个字符串"
    print(a+b)
help(my)

函数的__doc__属性：
　　函数内第一次末赋值给任何变量的字符串是此函数的文本文档字符串
　　此字符串会自动赋值给函数的__doc__属性
示例：
def cba:
    "这是一个字符串"
    pass
print(cba.__doc__)   # 这是一个字符串


函数定义语句的完整语法：
[@装饰器1]
[@装饰器2]
[...]
def 函数名([位置参数],[*元组形参],[命名关键字参数],[**字典形参]):
    "文档字符串"
    语句块
    


模块 module
　什么是模块
　　模块是一个包含有一系列变量，函数，类等组成的程序组
　　模块是一个文件，模块文件通常以　.py结尾
　作用：
　　１．让一些相关变量，函数，类等有逻辑的组织在一起，使逻辑结构更加清晰
　２．模块中的变量，函数和类可提供给其他模块使用
　模块的分类：
　　内置模块(biultins)，在解释器的内部可以直接使用
　　标准模块，安装python时已安装且可直接使用
　　第三方模块(通常为开源)，需要自己安装
　　用户自己；编写的模块(可以作为其他人的第三方模块)　

模块的导入 import
import 语句
　　语法：
　　　　import 模块名1　[as 模块新名1][,模块名2[as 模块新名2],...]
  示例：
  import math　as r # 导入数学模块命新名为r
  import sys ,os # 导入　sys,os　模块
  作用：
  　将某模块整体导入到当前模块
  用法：
  模块名.属性名

  help(模块名)　　查看模块内的变量，函数，类等



练习：
１．输入一个圆的半径，打印这个圆的面积
２．输入一个圆的面积，打印这个圆的半径
(要求用math模块内的函数和变量)
import math
r=int(input("输入圆的半径:"))
d=math.pi*r**2等同于d=math.pi*math.pow(r,2)
print("圆的半径",d)

n=int(input("输入一个圆的面积:"))
k=math.sqrt(n/math.pi)等同于k=(n/math.pi)**0.5
print("圆的面积",k)


>>>import math 
>>>math.(按两下	Tab键)　　　导出所有math函数

form import 语句
语法：
　　form 模块名　import 模块属性名1 [as 属性新名1],模块属性名2　[as 属性新名2]...
作用：
　　将某模块的一个或多个属性导入到当前模块的作用域
示例：
from math import pi,aqrt
from math import factorial as fac
from math import sin
area = pi　*　10　**　2 # 可以直接使用导入的函数名或变量
>>>form math import pi  # 只导入了pi 用时不用加math.
>>>import math   # 导入数学模块
>>>from math import sin # 只导入了sin 用时不用加math.
>>>from math import sin,cos,tan,pi # 可以同时倒入多个
>>>from math import * # 导入输入数学模块的全部


form import *语句
　　语法：
　　form 模块名　import *
  作用：
  　　将某模块所有属性导入当前模块
  示例：
  from math import *(少用，避免变量名冲突)
  print(sin(pi/2))
  print(factorial(10))

dir 函数
  格式
  　　dir ([对象])->返回一个字符串列表
  说明：
  　如果没有参数调用，则返回当前作用域内的所有变量的列表
  　如果给定一个对象作为参数，则返回这个对象的所有变量的列表
 　　1.对于模块，返回这个模块的全部属性
 　　2.对于一个类对象，返回类对象的所有变量，并递归基类对象的所有属性
 　　3.对于其他对象返回所有变量，类变量和基变量

>>>import math
>>>dir(math)
>>>from math import *
>>>dir()


数学模块 math 
  模块名math

math.ceil(x) 对x向上取整，比如x=1.2，返回2 
math.floor(x) 对x向下取整，比如x=1.2，返回1 
math.sqrt(x) 返回x的平方根 
math.factorial(x) 求x的阶乘 
math.log(x[, base]) 返回以base为底x的对数, 如果不给出base,则以自然对数e为底 
math.log10(x) 求以10为底x的对数 
math.pow(x, y) 返回 x**y (x的y次方) 
math.fabs(x) 返回浮点数x的绝对值 
角度和弧度degrees互换  
math.degree(x) 将弧度x转换为角度 
math.radians(x) 将角度x转换为弧度 
三角函数  
math.sin(x) 返回x的正弦(x为弧度) 
math.cos(x) 返回x的余弦(x为弧度) 
math.tan(x) 返回x的正切(x为弧度) 
math.asin(x) 返回x的反正弦(返回值为为弧度) 
math.acos(x) 返回x的反余弦(返回值为为弧度) 
math.atan(x) 返回x的反正切(返回值为为弧度) 


常见函数：



练习：
　请编写函数fun(n)其功能是计算并输出下载多项式的和
sn=1/1!+1/2!+1/3!+...+1/n!

编写函数fun(n) 他的功能是计算下载多项式的和并返回：
s=1+x+x**2/2!+x**3/3!+x**n/n!
print(fun(10))
import math as r
def fun(n):
    s=0
    for x in range(n+1):
        s+=1/r.factorial(x)
    return s
print(fun(10))

def fun(x):
    def fu(n):
        sn=0
        for a in range(n+1):
            sn+=x**a/r.factorial(a)
        return sn
    return fu

fg=fun(3.1)
print(fg(10))
方法二：
def fun(x,n):
    s=sum(map(lambda i: x**i/factoral(i),range(n+1)))
    return s
print(fun(3.1,10))


练习：
　　　已知有五位朋友在一起
　　　第五位朋友比第四个人大２岁
　　　第四位朋友比第三个人大２岁
　　　第三位朋友比第二个人大２岁
　　　第二位朋友比第一个人大２岁
　　　第一位朋友今年１０岁
　　　编写程序算出第五个人的几岁

def fdu():
    s=10
    for x in range(1,5):
        s+=2
    return s
print(fdu())


2.改写之前的学生管理项目源码，要求带有操作界面：
１．添加学生信息
２．显示所有学生的信息
３．删除学生信息
４．修改学生成绩
５．按学生成绩高低显示学生信息
６．按学生成绩低高显示学生信息
７．按学生年龄高低显示学生信息
８．按学生年龄低高显示学生信息
９．退出
一个功能一个函数



day 15


时间模块　time

time.altzone  夏def show_time():
    while True:
        t=time.localtime()
        # s="\r %02d:%02d:%02d"% (t[3],t[4],t[5])
        s="\r %02d:%02d:%02d"% t[3:6]
        print(s,end="")
        time.sleep(1)
show_time()
 
y=int(input("输入年"))
m=int(input("输入月"))
d=int(input("输入日"))
t=time.mktime((y,m,d,0,0,0,0,0,0))
print(t)
d=time.localtime(t)
w=d[6]
print(w)
er=['星期一','星期二','星期三','星期四','星期五','星期六','星期日']
print(er[w])
qw=time.time()-t
asd=qw/(60*60*24)
print(asd)
a=int(input("请输入时间:"))
o=time.asctime((a))
print(o)
b=int(input("请输入你的生日:"))
g=t.mktime(b)
print(t.localtime(g))

time.altzone 夏令时时间与UTC时间差(秒为单位) 
time.daylight 夏令时校正时间 
time.timezone 本地区时间与UTC时间差(秒为单位) 
time.tzname 时区名字的元组， 第一个名字为未经夏令时修正的时区名,第一个名字为经夏令时修正后的时区名 

注： CST为中国标准时间(China Standard Time UTC+8:00)



time.time() 返回从计算机元年至当前时间的秒数的浮点数(UTC时间为准) 
time.sleep(secs) 让程序按给定秒数的浮点数睡眠一段时间 
time.gmtime([secs]) 将给秒数转换为用UTC表达的时间元组 
time.asctime([tuple]) 将时间元组转换为日期时间字符串 
time.mktime(tuple) 将本地日期时间元组转换为新纪元秒数时间(UTC为准) 
time.localtime([secs]) 将UTC秒数时间转换为日期元组（以本地时间为准) 

示例：
此示例示意time模块中的sleep函数的用法
import time
time.sleep.(5.5)#此时让程序睡5.5秒
print("11111")
time.sleep(10)
print("22222")
time.sleep.(20)
print("33333")

>>> time.gmtime()
time.struct_time(tm_year=2018, tm_mon=4, tm_mday=20, tm_hour=2, tm_min=4, tm_sec=6, tm_wday=4, tm_yday=110, tm_isdst=0)
>>> time.asctime((2008,8,8,20,8,8,0,0,0))
'Mon Aug  8 20:08:08 2008'
>>> time.mktime((2008,8,8,20,8,8,0,0,0))
1218197288.0
>>> time.localtime((1218197288.0))
time.struct_time(tm_year=2008, tm_mon=8, tm_mday=8, tm_hour=20, tm_min=8, tm_sec=8, tm_wday=4, tm_yday=221, tm_isdst=0)

练习：
　　写一个程序，以电子时钟的格式显示时间：
hh:mm:dd
写一个程序，输入你的生日
计算出你出生的那天是星期几
计算你已经出生多少天

import time 
def show():
    t=time.localtime()
    s="%2d:%2d:%2d" %t[3:6]
    print(s)
show()
y=int(input("输入年"))
m=int(input("输入月"))
d=int(input("输入日"))
t=time.mktime((y,m,d,0,0,0,0,0,0))
print(t)
d=time.localtime(t)
w=d[6]
print(w)
er=['星期一','星期二','星期三','星期四','星期五','星期六','星期日']
print(er[w])
qw=time.time()-t
asd=qw/(60*60*24)
print(asd)




系统模块  sys
  与系统相关的信息和函数
sys.path 模块搜索路径 path[0] 是当前脚本程序的路径名，否则为 '' 
sys.modules 已加载模块的字典 
sys.version 版本信息字符串 
sys.version_info 版本信息的命名元组 
sys.platform 操作系统平台名称信息 
sys.argv 命令行参数 argv[0] 代表当前脚本程序路径名 
sys.copyright 获得Python版权相关的信息 
sys.builtin_module_names 获得Python内建模块的名称（字符串元组） 
标准输入输出时会用到  
sys.stdin 标准输入文件对象，多用于input() 
sys.stdout 标准输出文件对象,多用于print() 
sys.stderr 标准错误输出文件对象, 用于输出错误信息 

sys模块的方法

sys.exit([arg]) 退出程序，正常退出时sys.exit(0) 
sys.getrecursionlimit()  
sys.getrecursionlimit() 得到递归嵌套层次限制（栈的深度） 
sys.setrecursionlimit(n) 得到和修改递归嵌套层次限制（栈的深度） 


示例：

import sys
def fun():
    print("进入函数")
    sys.exit()　　# 退出程序
    print("退出函数")

fun()
print("退出程序")


自定义模块

示例：
－－－－－－－－－－－－－－－－－－－－－－－－－－
此文件名为mymod.py  # 被导入模块
此示例用来示意自定义模块的定义和导入
def fac(n):
    print("正在计算",n,"的阶乘...")

def sum_fac(n):
    print("正在计算",n,"的阶乘的和")

name1='audi'
name2='tesla'

－－－－－－－－－－－－－－－－－－－－－－－－－
此示例来示意调用mymod.py中的函数和变量
此文件名为test.py　　# 主模块
import mymod     #导入自定义的mymod模块
mymod.fac(10)
mymod.sum_fac(30)
print("mymod.name1=",mymod.name1)
－－－－－－－－－－－－－－－－－－－－－－－－－

注：两个文件要在同一个文件夹下，否则不能调用
　　　模块名一定要要用英文标识符

导入模块时的路径索引顺序:
１．索引程序的运行时路径(当前路径)
２．搜索sys.path里提供的路径
３．搜索内置模块

>>>import sys
>>>sys.path.append("/home/tarena/")
>>>import mymod


模块化编程的优点：
１．有利于多人合作开发
２．是代码更加易于维护
３．提高代码的复用率
４．模块化编程有助于解决函数名和变量名冲突(重名)问题，模块内的变量的作用域为模块内全局


模块的加载过程：
　在模块导入时，模块的所有语句都会执行
　如果一个模块已经导入，则再次导入时不会重复执行模块内的语句

模块的重新加载
　　import imp
  imp.reload(模块名)　#重新加载已经加载过的模块名模块

模块被导入和执行的过程：
１．先搜索相关路径找模块(.py)
２.判断是否有此模块对应的.pyc文件，如果没有此文件，则用.py生成相应的.pyc 文件再进行加载
３．如果文件已经存在,则判断.pyc文件和.py文件的修改时间，再决定是否重新生成.pyc文件
模块的编译 compile
         编译　　　　　　　　　　　　解释执行
mymod.py------>>mymod. pyc------>python3

用ls -l 查看修改时间



模块的文档字符串：
　　模块内第一行没有赋值给任何变量的字符串为文档字符串
　　此文档字符串可以用help函数查看


说明：
　　模块的文档字符串被绑定在模块的　__doc__　属性上


模块的__file__属性
　　用来绑定相对应的文件路径名
示例：
import mymod2
print(mymod2.__file__)

模块的__name__属性：
 用来记录模块自身名字

作用：
１．记录模块名
２．用来判断是否为主模块
__name__说明：
1.当此模块为主模块(也就是第一个运行的模块)运行时,__name__绑定'__main__'
2.当此模块不是主模块时，模块为名文件名去掉'.py'
注：谁先执行，谁是主模块，主模块例有导入模块(import xxx)
示例：
示意__main__属性
def fac(n):
    print("正在计算",n,"的阶乘...")

print("mymod的__name__属性:",__name__)
>>>import mymod
# mymod


模块的__all__列表
模块中的__all__列表是一个用来存放可导出属性的字符串列表
作用：

当用from import * 语句导入模块时，只导入__all__列表内的属性(只对这条语句有用)
示例：
此示例用来示意__all__列表的用法

__all__=['fun1','name1']　# 加了all列表只能用导入列表里的名字
def fun1():
    pass
def fun2():
    pass
def fun3():
    pass


name1="aaa"
name2="bbb"


模块的隐藏属性：
　　模块中以下划线('_')开头的属性，在from import　* 语句导入时，将不会导入；通常这些属性为隐藏属性

示例：
mymod5.py
def fun():
    print("hello")

def _fun1():
    print("hello")


name="tarena"
_name1="world"


>>>from mymod5 import *
>>>dir()
['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'fun', 'name']


标准库模块：
随机模块 random
作用：
　用于模拟或生成随机数的模块

模块函数说明：

random模块是用于模拟或生成随机输出的模块.

import random as R


R.random() 　　　　　　返回一个[0, 1) 之间的随机实数 

R.uniform(a,b) 　　返回[a,b) 区间内的随机实数 

R.randrange([start,] stop[, step]) 　　　返回range(start,stop,step)中的随机数

R.choice(seq) 　　　　　　　　　　　　　从序列中返回随意元素 

R.randint(1,11) 返回范围[a，b]中的随机整数，包括两个端点 

R.shuffle(seq[, random]) 　　　随机指定序列的顺序(乱序序列）

R.sample(seq,n) 　　　　　从序列中选择n个随机且不重复的元素 

R.getrandbits(nbit) 以长整型的形式返回用nbit位来表示的随机数 

R.seed(a=None) 用给定的数a设置随机种子,不给参数a则用当前时间设置随机种子 


>>> import random
>>> random.random()
0.3373706564106985
>>> random.random()
0.7227170514700194
>>> random.random()
0.7419690942488993

>>> random.uniform(5,10)
9.803280493646284
>>> random.uniform(5,10)
6.130460045250688
>>> random.uniform(5,10)
8.900418013878186
>>> random.uniform(5,10)
9.155952223355587

>>> random.randrange(1,10,2)
1
>>> random.randrange(1,10,2)
3
>>> random.randrange(1,10,2)
9
>>> random.randrange(1,10,2)
5
>>> random.randrange(1,10,2)

>>> random.choice([1,2,3,4,5,6,])
4
>>> random.choice([1,2,3,4,5,6,])
3
>>> random.choice([1,2,3,4,5,6,])
5
 
>>> s=list(range(15))
>>> s
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
>>> random.shuffle(s)
>>> s
[4, 6, 2, 1, 12, 14, 5, 10, 8, 7, 3, 0, 11, 9, 13]
>>> >>> random.sample(s,2)
[5, 14]


练习：
假设可以作为密码的字符有：
A-Z  a-z  0-9　　　　下划线
写一个程序随机生成六位密码
def get_random_passwd(n):
    source=[0,1, 2, 3, 4, 5, 6, 7, 8, 9, a,b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C', D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,_]
    s=''
    for _ in range(n):
        s+=r.choice(source)
    return s
print("生成的密码:",get_random_passwd(6))


包(模块包)package

命名包:文件夹需要__init__.py

 包是将模块以文件夹的组织形式进行分组管理的方法
 作用：
 １．将一系列模块进行分类管理，有利于防止命名冲突
 ２．可以在需要时加载一个或部分模块而不是全部模块
 包示例：
 mypack/
     __init__.py
     menu.py
     games/
         __init__.py
         contra.py     # 魂斗罗
         supermario.py # 超级玛利亚
         tanks.py　　　　　 # 坦克大战
     office/
         __init__.py
         excel.py
         word.py
         powerpoint.py
包的导入语法：
import 包名　[as　包别名]
import 包名.模块名 [as　模块新名]
import 包名.子包名.模块名 [as 模块新名]

from 　包名　import 模块名　as 模块新名
from 包名.子包名 import 模块名　[as 模块新名]
from 包名.子包名.模块名 import 属性名[as 属性新名]

from 包名 import *
from 包名.模块名 import *



练习：
１．编写一个闹钟程序，启动设置定时时间：
(小时和分钟)到时间后打印"时间到......"然后退出程序

import time
def alarm():
    h=int(input("请输入小时:"))
    m=int(input("请输入分钟:"))
    while True:
        ct=time.locatime()
        if (h,m)==ct[3:5]
            print("时间到...")
            return
        print("\r%2d:%2d:%2d" % ct[3:6],end="")
        time.sleep(1)
alarm() 


２．模拟斗地主发牌，扑克牌共54张:
花色：
　　黑桃('\u2660'),梅花('\u2663')
  方块('\u2665'),红桃('\u2666')
  数值：
  A2-10JQK
  大小王
  三个人，每人发17张牌，底牌三张
  输入回车，打印第一个人17张牌
 　输入回车，打印第二个人17张牌
 　输入回车，打印第三个人17张牌
 再输入回车，打印三张底牌
 
def get_new_poker():
    kinds = ['\u2660','\u2663','\u2665','\u2666']
    numers = ['A',]
    numbers +=[str(x) for x in range(2,11)]
    numbers += ['J','Q','K']
    l=[k+n for k in kinds for n innumbers]
    l += ['BK','SK']
    return l


poker=get_new_poker()
print(poker)




 day 16
 包

__init__.文件
  是常规包内必须存在的文件,__init__.py会在导入包时自动调用
 作用：
 １．编写此包内容
 ２．在内部添加包文档字符串
 ３．在__init__.py　文件内可以加载此包所依赖的其他模块


包的__all__列表
作用：
用来记录此包中有哪些子包或模块需要导入
当用from 包import *　语句时，只查找__all__中的模块或子包
说明：
__all__列表只用from xxx import * 语句起作用
说明：
　当包或子包内的模块被加载时，上一层的包也会被导入
例如：
import mypack.games,contra
# 实质会先导入mypack,再导入games,再导入contra

#以下语句会将mypack/__init__.py
#内__all__列表里指定的文件一同导入

from mypack import *

包的相对导入:
　　包的相对导入是指包内的模块的相互导入

语法：
　　from 相对路径包或模块 import 属性或模块名
　　或
  from 相对路径包或模块 import *
相对路径：
　　在 from xxxx import 语句中，　xxxx　部分可以使用相对路径
. 代表当前目录
.. 代表上一级目录
... 代表上二级目录
....　以此类推
注：　
１．相对导入不能超过包的外部
２．相对导入要避免循环导入
相对导入：
　import mypack.games.contra as contra　



异常(基础) exception

什么是错误？
 错误是指由于逻辑或语法等导致一个程序无法正常执行的问题

错误的特点：
 有些错误无法预知

什么是异常？
　　异常是程序出错时标识的一种状态
　　当异常发生时，程序不会再向下执行，而转去调用此函数的地方待处理此错误并恢复为正常状态
异常的作用：
　　通知上层调用者，有错误产生需要处理用作信号

try语句的两种语法：
　　try-except 语句
　　try-finally　语句
try-except语句的语法
try:
    可能触发异常的语句
except 错误类型1 [as 变量1]:
    异常处理语句1
except 错误类型2 [as 变量2]:
    异常处理语句2
except (错误类型3 错误类型4，...):
    异常处理语句3 ....
except:
    异常处理语句other
else:
    末发生异常的语句
finally:
    最终语句
try-except 语句　作用：
　　尝试捕获异常，将程序转为正常状态并继续执行

try -except语句语说明：
１．as 子句是用于绑定错误对象的变量，可以省略
２．except 子句可以有一个或多个，但至少要有一个
３．else 子句最多只能有一个，也可以省略
４．finally 最多只能有一个，也可以省略

　as 变量　　示例：

def div_apple(n):
    s=input("请输入人数:")
    cnt=int(s) 
    result=n/cnt
    print("每个人分了",result,"个苹果")
try:    
    div_apple(10)
except ValueError　as err:
　　　　print("发生错误，苹果收回")
    print("错误的值是",err)

print("程序正常退出")


示例：
def div_apple(n):
    """此示例用来分苹果来示意捕获异常"""
    print("%d个苹果你想要分给几个人" % n)
    s=input("请输入人数:")
    cnt=int(s) #<<==此处可能引起valueError(值)类型的错误
    result=n/cnt
    print("每个人分了",result,"个苹果")
try:    
    div_apple(10)
except ValueError:
    print("发生之值错误，已转为正常状态")
except ZeroDivisionError:
    print("发生了被零除的错误，苹果收回办公室")

print("程序正常退出")
#情况一
10个苹果你想要分给几个人
请输入人数:2o
发生之值错误，已转为正常状态
程序正常退出
#情况二
10个苹果你想要分给几个人
请输入人数:10
每个人分了 1.0 个苹果
程序正常退出
#情况三
10个苹果你想要分给几个人
请输入人数:0
发生了被零除的错误，苹果收回办公室
程序正常退出
def div_apple(n):
    """此示例用来分苹果来示意捕获异常"""
    print("%d个苹果你想要分给几个人" % n)
    s=input("请输入人数:")
    cnt=int(s) #<<==此处可能引起valueError(值)类型的错误
    result=n/cnt
    print("每个人分了",result,"个苹果")
try:    
    div_apple(10)
except (ValueError,ZeroDivisionError):
    print("发生错误，苹果收回")
print("程序正常退出")

示例：    
def div_apple(n):
    """此示例用来分苹果来示意捕获异常"""
    print("%d个苹果你想要分给几个人" % n)
    s=input("请输入人数:")
    cnt=int(s) #<<==此处可能引起valueError(值)类型的错误
    result=n/cnt
    print("每个人分了",result,"个苹果")
try:    
    div_apple(10)
except ValueError:
    print("发生错误，苹果收回")
except:
　　　　# 发生了除了值错误以外的错误，在此执行
    print("发生了除了值错误以外的错误，在此处理")
else:
　　　　# 此处语句只在没有发生异常时才会执行
    print("没有发生错误，苹果分完了")
finally:
    # 此子句内的语句无论是否发生异常都一定会执行
    print("我一定会执行!!!")

print("程序正常退出")


练习：
写一个函数 get_score() 来获取用户输入的学生成绩(0~100),如果输入错误则返回0，如果用户输入的数是0~100之间的数，返回这个数

def get_score():
    s=int(input("请输入成绩:"))
    if 0<=s<=100:
        return s
try:
    score=get_score()
except:
    score=0
print("这个学生成绩为",score)

方法二：
def get_score():
    s=input("请输入成绩:")
    try:
        i=int(s)
    except ValueError:
        return 0

    if 0<=i<=100:
        return i
score=get_score()          
print("这个学生成绩为",score)


try-finally语句
语法:
  try:
      可能触发异常的语句
  finally:
      最终语句

语法说明：
　　finally 子句不可以省略
　　一定不存在 except 子句

作用：
　　通常用　try-finally　语句来做触发异常时必须要处理的事件，无论是否发生，finally子句都会被执行
注：
　　try-finally语句不会改变程序的(正常/异常)状态


示例：
此示例示意try-finally语句的用法:
# 厨房做饭为例：
　　　　# 打开天然气后必须要关闭天然气
def fry_egg():
    print("打开天然气")
    try:
        count=int(input("请输入鸡蛋个数:"))
        print("完成煎鸡蛋!共煎了%d个鸡蛋" % count)
    finally:
        print("关闭天然气")

fry_egg()

def fry_egg():
    print("打开天然气")
    try:
        try:
            count=int(input("请输入鸡蛋个数:"))
            print("完成煎鸡蛋!共煎了%d个鸡蛋" % count)
        finally:
            print("关闭天然气")
    except ValueError:
        print("程序转为正常")

fry_egg()

def fry_egg():
    print("打开天然气")
    try:
        count=int(input("请输入鸡蛋个数:"))
        print("完成煎鸡蛋!共煎了%d个鸡蛋" % count)

    finally:
        print("关闭天然气")
try:
    fry_egg()
except ValueError:
    print("程序转为正常")
print("程序正常退出")


rais 语句：
作用：
　　触发一个错误,让程序进入异常状态
语法：
　　raise 异常类型
　　或
　　raise 异常对象
示例：
此示例示意raise语法的用法
def make_except(n):
    # 假设n必须是0~100之间的数
    print("begin...")
    if n > 100: # 传过的参数无效，怎么告诉调用者呢？
        raise ValueError
    if n<0:
        raise ValueError("参数小于零错误:%d" % n)
    print("end")
value=int(input("输入一个整数:"))
try:
    make_except(value)
except ValueError as e:
    print("make_except 抛出错误，此异常状态已处理")
    print("错误的值是",e)
    print("发生错误")
print("程序正常完成")

assert 语句(断言语句)
语法：
  assert 真值表达式，错误数据(通常是字符串)
作用：
 　当真值表达式为False时，用错误数据创建一个AssertionError类型的错误，并进入异常状态
 等同于：
 　if 真值表达式==False:
     　raise AssertionError(错误数据)

 示例：
def get_age():
    a=input("请输入年龄:")
    a=int(a)
    assert a<140, "年龄不可能大于140!!!"
    assert a>=0,  "年龄不可能是负数!!!"
    return a
age=get_age()
print("您输入的年龄是:",age)

def get_age():
    a=input("请输入年龄:")
    a=int(a)
    assert a<140, "年龄不可能大于140!!!"
    assert a>=0,  "年龄不可能是负数!!!"
    return a
try:
    age=get_age()
except AssertionError as err:
    print("发生断言错误!错误对象是:",err)
    age=0
print("您输入的年龄是:",age)

为什么要用异常处理机制：
　　在程序调用层数较深时，向主调函数传递错误信息需要层层的return 返回比较麻烦，所以用异常处理机制
示例：
def f1():
    print("开始盖房子打地基...")
    print("地基完工")
def f2():
    print("开始盖房子以上部分")
    print("房子完工")
def f3():
    """第二承包商找人干活"""
    f1()					
    f2()
def build_house():
    f3()
build_house()

def f1():
    print("开始盖房子打地基...")
    # raise ValueError("代表挖出文物")
    print("地基完工")
def f2():
    print("开始盖房子以上部分")
    raise ZeroDivisionError("要建高压线")
    print("房子完工")
def f3():
    """第二承包商找人干活"""
    f1()
    f2()
def build_house():
    f3()
try:
    build_house()
except ZeroDivisionError as err:
    print("房子没盖好,因为",err)
else:
    print("房子盖好了")



练习：
１．一个球从100米高度落下，每次落地反弹高度为原高度的一半，再落下
１）写程序算出皮球从第十次落下后反弹高度是多少？
２）球一共经过多少米路径？

tour = []
height = []
 
hei = 100.0 # 起始高度
tim = 10 # 次数
 
for i in range(1, tim + 1):
    # 从第二次开始，落地时的距离应该是反弹高度乘以2（弹到最高点再落下）
    if i == 1:
        tour.append(hei)
    else:
        tour.append(2*hei) 
    hei /= 2
    height.append(hei)
 
print('总高度：tour = {0}'.format(sum(tour)))
print('第10次反弹高度：height = {0}'.format(height[-1]))
２．打印九九乘法表：

def fun1():
    for i in range(1,10):
        for j in range(1,i+1):
            print("%dx%d=%d" % (j,i,j*i),end=" ")
        print()
fun1()

3.分解质因数：
输入一个正整数，分解质因数：
如输入：　90 则打印：
　　　90=2*3*3*5
(原质因数是指最小能被原数整除的素数(不包含1))





day 17
迭代器 Iterator 和　生成器 Generator

什么是迭代器
　　迭代器是访问可迭代对象的一种方式，用迭代器可以访问可迭代对象
　　迭代器是指iter(可迭代对象)　返回的对象
　　迭代器可以用next(it)函数获取可迭代对象的数据

迭代器函数 iter 和　next
　　iter(iterable)  从可迭代对象中返回一个迭代器，iterable必须是能提供一个迭代器的对象
　　next(iterator)  从迭代器iteraror中获取下一个记录，如果无法获取下一条记录，则触发StopIterator异常

迭代器说明：
　　迭代器只能往前取值，不会后退
　　用iter函数可以返回一个可迭代对象的迭代器


示例：
l=[2,3,5,7]
it=iter(l) #用iter返回一个迭代器用it绑定
next(it) # 2  # 用next(it)　用可迭代器来获取l中的元素
next(it) # 3
next(it) # 5
next(it) # 7
next(it) # StopIteration # 通知 next调用者，已无数据

# 用迭代器获取 range 对象的数据
it=iter(range(1,10,3))
next(it)
next(it) # 2  
next(it) # 3
next(it) # 5
next(it) # 7
next(it) # StopIteration


l=[2,3,5,7]
用for 循环来访问可迭代对象中的数据
for x in l:
    print(x)
# 用while 循环能否访问可迭代对象中的数据?
# 第一步，让l给我们一个迭代器
l=[2,3,5,7]
it=iter(l)
while True:
    try:
        x = next(it)
        print(x)
    except StopIteration:
        break

练习：
一直有一个集合：
s={"工商银行","建设银行","中国银行","农业银行"}
１．用for 语句遍历集合中的元素并打印
２．将上面的for 语句改写为while 语句实现上面同样的功能

1.
s={"工商银行","建设银行","中国银行","农业银行"}
for x in s:
    print(x)
2.
s={"工商银行","建设银行","中国银行","农业银行"}
a=iter(s)
while True:
    try:
        x=next(a)
        print(x)
    except StopIteration:
        break




生成器 generator (python 2.5及之后的版本)
什么是生成器：
　　生成器是能够动态提供数据的对象，生成器对象也是可迭代对象

生成器有两种：
　　生成器函数
　　生成器表达式

生成器函数定义：
　　含有yield语句的函数是生成器函数，此函数被调用将返回一个生成器对象
　　yield 翻译为(产生或生成)

yield语句：
语法：
　　yield 表达式


说明：
  yield　用于def函数中，目的是将此函数作为生成器函数使用
  yield　用来生成数据，供next(it)函数使用　　


示例：
def myyield():
    yield 2
    yield 2+1  # 等同于 yield 3
    yield 5
    yield 7
    print("生成器函数调用结束")
gen=myyield()
# print(gen)  # gen绑定生成器对象，此对象为可迭代对象
for x in gen:
    print(x)

def myyield():
    print("即将生成2")
    yield 2
    print("即将生成3")
    yield 3
    print("即将生成5")
    yield 5
    print("即将生成7")
    yield 7
    print("生成器函数调用结束")
gen=myyield()
it=iter(gen) # 返回迭代器
print(next(it))
print(next(it))　　# myyield 将从上一次停止的位置(yield 2)开始执行



示例：
  # 写一个生成器函数my_integer(n)生成1~n的整数：
def my_integer(n):
    i=1  #　先初始化变量i将其设置为起始值
    while i<n:  # 循环判断是否已到终止点，如果未到则生成
        yield i  # 生成整数
        i+=1   # 控制条件
for x in my_integer(5000):
    print(x)



练习：
　　写一个函数，myodd(ster,stop)
用于生成start开始到stop结束(不包含stop)的奇数

def myodd(s,a):
    i=s
    while i<a:
        if i%2:
            yield i
        i+=1
for x in myodd(10,20):
    print(x)




生成器表达式：
语句：
　　(表达式　for 变量 in 可迭代对象 [if 真值表达式])
注：　[]　内的if部分可以省略

作用：
　　用推导式形式生成一个新的生成器
示例：
gen=(x**2 for x in range(1,5))
it=iter(gen)
next(it)  # 1
next(it)  # 4
next(it)  # 9
next(it)  # 16
next(it)  # StopIteration


迭代工具函数：
　　迭代工具函数的作用是生成一个个性化的可迭代对象

zip(iter1[,iter2,...])返回一个zip对象，此对象用于生成一个元组，此元组的个数是有最小的可迭代对象决定，元组内容是可迭代对象iter1和iter2中的元素的组合

enumerate(iterable[,start])
生成带索引的枚举对象，返回的迭代类型为索引-值对(index-value)对，默认索引从零开始，也可以用start指定

示例：
此示例示意zip函数的用法：
numbers=[10086,10000,10010,95588]
name=['中国移动','中国电信','中国联通']
for t in zip(numbers,name):
    print(t)
#
(10086, '中国移动')
(10000, '中国电信')
(10010, '中国联通')

numbers=[10086,10000,10010,95588]
name=['中国移动','中国电信','中国联通'']
print(dict(zip(numbers,name)))
# {10000: '中国电信', 10010: '中国联通', 10086: '中国移动'}

此示例来示意zip函数的内部实现方法

def myzip(iter1,iter2):
    it1=iter(iter1)
    it2=iter(iter2)
    try:
        while True:
            a=next(it1)
            b=next(it2)
            yield(a,b)
    except:
        pass

numbers=[10086,10000,10010,95588]
name=['中国移动','中国电信','中国联通']
for t in myzip(numbers,name):
    print(t)


示例：
numbers=[10086,10000,10010,95588]
name=['中国移动','中国电信','中国联通']
for t in zip(range(1,10000),numbers,name):
    print(t)
####################
(1, 10086, '中国移动')
(2, 10000, '中国电信')
(3, 10010, '中国联通')

示例：
示意enumerate用法:

name=['中国移动','中国电信','中国联通']
for t in enumerate(name):
    print(t)
################
(0, '中国移动')
(1, '中国电信')
(2, '中国联通')

name=['中国移动','中国电信','中国联通']
for t in enumerate(name,1):
    print(t)
###############
(1, '中国移动')
(2, '中国电信')
(3, '中国联通')

练习：
写一个程序，读取任意行的文字数据，当输入空行时结束输入
打印带有行的输入结果：
方法一
def mytun():
    d=[]
    while True:
        a=input("请输入文字:")
        if a=="":
            break
        d.append(a)
    return d
for k,n in enumerate(mytun(),1):
    print("第%d行:" % k,n)
方法二：
def mytun():
    d=[]
    while True:
        a=input("请输入文字:")
        if a=="":
            break
        d.append(a)
    return d
def out_tex(d):
    for k,n in enumerate(d,1):
        print("第%d行:" % k,n)
y=mytun()
out_tex(y)

字符串和字节数组：
字节数(也叫字节序列) bytes
  作用：
  　　存储以字节为单位的数据
  说明：
  　　字节串是不可改变的序列
  　　字节是0~255之间的整数

8bit=1Byte

创建空的字节串的字面值
    b''
    b""
    b''''''
    b""""""
创建非空的字节串的字面值：
    B=b'hello'
    B=b"hello"
    B=b'''hello'''
    B=b"""hello"""
    B=b'abc\n123'
    B=b'\x41\x42'
示例：
>>> b''
b''
>>> b'hello'
b'hello'
>>> b'''hello'''
b'hello'
>>> b"""hello"""
b'hello'
>>> b'\x41'
b'A'


字节串的构造函数 bytes
　　bytes() 　　　　　　　　　　　　生成空的字节串　等同于b''
　　bytes(整数可迭代对象)　用可迭代对象初始化一个字符串
　　bytes(整数n) 　　　　　　　生成n个值为0的字节串
　　bytes(字符串，encoding='utf-8')
用字符串的转换编码生成一个字节串

示例：
>>> bytes()
b''
>>> bytes(5)
b'\x00\x00\x00\x00\x00'
>>> bytes("hello","utf-8")
b'hello'
>>> bytes("你好","utf-8")
b'\xe4\xbd\xa0\xe5\xa5\xbd'

betes　的运算：
　　+ + * *=
　　< <= > >= == !=
　　in  /  not in
　　索引和切片

>>> b'123'+b'5678'
b'1235678'　　# 八个字节
>>> b'abcd'*3
b'abcdabcdabcd'　　# 十二个字节
>>> bytes([65])<bytes([68])
True
B=b'ABCDE'
0x41 in B  # True

>>> B=b'ABCDEFGH'
>>> B[0]
65
>>> B[4]
69
>>> B[::2]
b'ACEG'
用于序列的函数：
 len, max, min, sum, any, all, 都可用于字节串


序列的方法：
　　详见：
   >>> help(bytes)

bytes　与　str的区别：
bytes　存储字节(0~255)
str   村塾字符(Unicode值)
bytes 与 str 转换
     编码(encode)
str ------------>  bytes
      b=s.encode(encoding='utf-8')

       解码(decode)
bytes ------------>str
      s=b.decode(encodeing='utf-8')
示例：
b="你好".encode('utf-8')
print(b)   # b'\xe4\xbd\xa0\xe5\xa5\xbd'
s=b.decode('utf-8')
print(s)   # '你好'


字节数组　bytearray
  可变的字节序列

创建函数 bytearray
　　bytearray()  创建空的字符串
　　bytearray(整数)
　　bytearray(整数可迭代对象)
　　bytearray(字符串，encode='utf-8')

操作：
+ += * *=
< <= > >= == !=
in / not in
索引 index 和 切片 slice
　　字节数组可以索引和切片赋值，赋值规则同列表的索引和切片赋值相同

示例：
ba=bytearray(b'abcdefg')
ba[0]=0x41 # ba=bytearray(b'Abcdefg')
ba[1::2]=bytearray(b'BDF')  # 修改bdf为大写

练习：
１．用生成器函数生成斐波那契数列的前n个数：
　　　　1,1,2,3,5,8,13
　　　　def fibonacci(n):
　　　1)输出前20个数
　　　2)求前30个数的和
方法一
def fun(n):
    count=0  # 记录当前已生成的个数
    if count>=n:
        return 
    yield 1
    count+=1
    if count>=n:
        return
    yield 1
    count+=1
    l=[1,1]
    while count<n:
        l.append(l[-1]+l[-2])
        yield l[-1]
        count+=1
for x in fun(20):
    print(x)

方法二
def fun(n):
    count=0  # 记录当前已生成的个数
    if count>=n:
        return 
    yield 1
    count+=1
    if count>=n:
        return
    yield 1
    count+=1
    a=1
    b=1
    while count<n:
        yield a+b
        a,b=b,a+b
        count+=1
for x in fun(20):
    print(x)
2.
print(sum(fun(30)))
２．写程序打印杨辉三角(只打印6层)
　　　　　　　　　1
        1 1
       1 2 1
      1 3 3 1
     1 4 6 4 1
   1 5 10 10 5 1





day 18

bytearray 的方法
BA代表bytearray
BA.clear()  清空字节数组
BA.append(n) 追加一个字节(n为0~255的整数)
BA.remove(value) 删除第1个出现的字节，如果没有出现，则触发ValueError错误
BA.reverse()  字节的顺序反转
BA.decode(encoding='utf-8') 将bytearray转换为字符串
BA.find(sub[,start[,end]]) 查找sub　字节数数组



文件：

什么是文件：
　　文件是用于数据存储的单位
　　文件通常用来长期存储设置
　　文件中的数据是以字节为单位进行顺序存储的

内存的读写速度快/磁盘的读写速度慢


文件的操作步骤：
　　打开文件
　　读写文件
　　关闭文件



文件的打开函数　open 
  open(file(文件名),mode(模式)='rt') 用于打开一个文件，返回此文件流对象，如果打开失败会触发IOError错误
  文件的关闭方法
  F.close()  # 关闭函数，释放系统资源
  示例：

此程序示意文件的打开和关闭
打开文件存在时：

file=open("lian.py")
print("打开文件成功")
# 通常在此进行读写文件内容
#关闭文件
file.close()
print("文件已关闭")

打开的文件不存在时：

try:
    file=open("1.py")
    print("打开文件成功")
# 通常在此进行读写文件内容
#关闭文件
    file.close()
    print("文件已关闭")
except IOError:
    print("文件打开失败")
读取一行：

try:
    file=open("lian.py")
    print("打开文件成功")
# 通常在此进行读写文件内容
    s=file.readline()
    print("第一行内容是",s)
#关闭文件
    file.close()
    print("文件已关闭")
except IOError:
    print("文件打开失败")



文件操作分为两种类型的操作：
　　文本文件操作
　　二进制文件操作

文本文件模式：

mode='t'
1.默认文件中的存储的内容为字符数据，以行为单位读取，采用系统默认的换行符进行分隔
２．对于文本文件的读写，需要用字符串(str)进行读取和写入数据

各操作系统默认的换行符：

    Linux 换行符 '\n'
    Windows 换行符　'\r\n'
    旧的Macintosh的换行符 '\r'
    新的Mac OS 换行符　'\n'

'r' 	以只读方式打开(默认)
'w' 	以只写方式打开，删除原有文件内容(如果文件不存在，则创建该文件并以只写方式打开)
'x' 	创建一个新文件, 并以写模式打开这个文件,如果文件存在则会产生"FileExistsError"错误
'a' 	以只写文件打开一个文件，如果有原文件则追加到文件末尾
'b' 	用二进制模式打开
't' 	文本文件模式打开 (默认) 
'+' 	为更新内容打开一个磁盘文件 (可读可写)

python 文件常用方法:

F.close() 	关闭文件(关闭后文件不能再读写会发生ValueError错误)
F.readline() 	读取一行数据, 如果到达文件尾则返回空行
F.readlines(max_chars=-1) 	返回每行字符串的列表,max_chars为最大字符(或字节)数
F.writelines(lines) 	写入多行字符串的列表到文件流
F.flush() 	把写入文件对象的缓存内容写入到磁盘

f=open("myto.txt","w")
f.write("aaaaaa")
f.flush()# 把缓冲的内容写入到磁盘
s=input("暂停...")
f.write("bbbbb")
f.close()

F.read(size = -1) 	从一个文件流中最多读取size个字符
F.write(text) 	写一个字符串到文件流中，返回写入的字符数



缺省模式是 'rt'

'w+b' 可以实现二进制随机读写，当打开文件时，文件内容将被清零

'r+b' 以二进制读和更新模式打开文件,打开文件时不会清空文件内容

'r+' 以文本模式读和更新模式打开文件,打开文件时不会清空文件内容


练习：
将如下数据用文本编辑器sublime写入到data.txt文件中
数据如下：
小张 13888888888
小李 13999999999
小赵 13666666666
写程序读取数据，打印以下格式:
姓名：小张　电话　13888888888

def fun():
    f=open("data.txt")
    while True:
        s=f.readline()
        if not s:
            f.close()
            return 
        a=s.rstrip()
        index=s.find(" ")
        name=a[:index]
        nuber=a[index+1:]
        print("姓名:",name,"电话:",nuber)
fun()

练习：
　１．写一个程序，读入任意行的文字信息，当输入空行是结束输入，将读入的字符串存于列表中，然后将列表里的内容写入的文件input.txt中
２．写一个程序，从input.txt中读取之前的数据，存入列表中，再加上行号进行打印显示
def fun1():
    l=[]
    while True:
        s=input("请输入字符串:")
        if not s :
            break
        l.append(s)
    return l
def fun2(l):
    f=open("input.txt","w")
    for x in l:
        f.write(x)
        f.write("\n")
    f.close()

fun2(fun1())
def fun5(fa="input.txt"):
    f=open(fa)
    l=[]
    while True:
        s=f.readline()
        if not s:
            break
        s=s.rstrip()
        l.append(s)
    f.close()
    return l
def print_file_info(l):
    for x,n in enumerate(l,1):
        print("第%d行" %x,n)
        
lst=fun5()
print_file_info(lst)


二进制文件操作：
　　打开模式: 'b'
  默认文件中存储的都是以字节为单位的二进制数据，通常有人为规定的格式，需要以字节为单位进行读写
  对二进制文件的读写，需要用字节串(bytes)进行操作

xxd命令：
　　查文件的十六进制内容

二进制文件操作方法 

F.tell() 	返回当前文件流的绝对位置
F.seek(offset, whence=0) 	改变数据流的位置，返回新的绝对位置
F.readable() 	判断这个文件是否可读,可读返回True,否则返回False
F.writable() 	判断这个文件是否可写,可写返回True,否则返回False
F.seekable() 	返回这个文件对象是否支持随机定位
F.truncate(pos = None) 	剪掉 自pos位置之后的数据，返回新的文件长度(字节为单位)

方法：
对于二进制文件
f.read(n)   　　　返回字节串(n代表最大字节数)
f.readline() 　　返回字节串
f.readlines()　　返回字节串列表

f.write(x)方法
　　　对于二进制文件,　x　必须为字节串

f.seek(offset,whence=0) 函数
offset偏移量：
　　大于零的数代表向文件末尾方向移动
　　小于零的数代表向文件头方向移动
whence 相对位置
0　代表从文件头开始偏移
1　代表从当前位置开始偏移
2 代表从文件尾开始偏移

示意seek方法的用法：

f=open('myto.txt','rb')
b=f.read(5)
#f.seek(10,0)
f.seek(-10,2)
#f.seek(5,1)
b=f.read(5)
print(b)
f.close()
#  b'abcde'

此示例示意以二进制模式读取文件
try:
    f=open("asd.txt","rb") # 打开模式为"rb"
    print("打开文件成功")
    b=f.read()
    print(b)
    s=b.decode('utf-8')
    print("转码后:",s)
except IOError:
    print("打开文件失败")

f=open("mydata.bin","wb") # "wb"二进制写模式
print("文件打开成功")
f.write(b'hello\xe4\xb8\xad') 
s="我是汉字"
r=f.write(s.encode('utf-8'))
print("写入",s,"共写入",r,"个字节")
f.close()
示意tell方法的用法：
f=open('mydata.bin','rb') # 二进制方式打开
print("刚打开时的文件流位置为:",f.tell())
b=f.read(5)
print("读出五个字节后的文件流位置:",f.tell())
f.close()


汉字编码
　　国标系列：
    GB18030(2字节或4字节编码，共27533个)
      GBK (2字节，共21003个)
      　　GB2312 (2字节，共6763个)
    (常用于Windows)
  国际标准：
  　　UNICOD16/UNICODE32  <<<--->>>UTF-8
    (常用于Linux / Mac OS X /IOS /Android)
     UTF-8(8-bit Unicode Transformation Format)
编码字符串:

'gb2312'
'gbk'
'gb18030'
'utf-8'
'ascii'
用于　encode　和 decode 方法中

编码注释：
　　在源文件的第一行或第二行写入如下格式的内容
# -*- codeing:gbk -*-
或
# -*- coding:utf-8 -*-
是告诉python3 解释执行器当前文件的编码是什么

练习：
１．修改学生管理系统的代码，将其改为分模块
建议：
１．把显示菜单放在一个模块内
２．把对学生的操作放在一个模块内
３．把主事件循环while True 选择输入放在一个模块内
２．在菜单添加两个功能:
  9) 保存学生管理信息到文件(si.txt)
  10) 从文件中读取数据(si.txt)
  建议用逗号分割数据






day 19
标准输入输出文件
sys.stdin
sys.stdout
sys.stderr
模块名：　sys

Linux下　ctrl+d　输入文件结束符

说明：
　　每一个python程序启动后都会有以上三个文件已经打开供我们使用

示例：
示意标准输出和标准错误输出
import sys
sys.stout.write("hello world\n")
等同于print("hello world",end="\n")
#以下程序会出错：
#sys.stdout.close()
sys.stderr.write("我的出现是个错误 \n")
示意sys.stdin:
import sys
1.
s=sys.stdin.read(10)#默认从键盘获取数据
print(s)
s2=sys.stdin.read(10)
print(s2)
2.
print("请开始输入:")
s=sys.stdin.read()
print("输入的是:",s)

面向对象编程：

类　class 和　对象 object

什么是对象：
　　对象是指现实中的物体或实例
什么是面向对象：
把一切看成对象(实例)，对象和对象之间用方法(行为)建立关联关系
什么是类：
　　拥有相同属性和行为的对象分为一组，即为一个类
　　类是用来描述对象的工具

面向对象的示意：
车(类) -------->>BYD E6(京A.88888)对象(实例)
　　　　　\
      \------->>BMW X5(京B.00000)对象(实例)


狗(类)　----->>小京巴(户籍号:00001)对象(实例)
     \
      \---->>导盲犬(户籍号:00002)对象(实例)


int(类)------>>100(对象)
　　　　　 \
       \---->>200对象(实例)


类的创建语法：
　　class 类名(继承列表):
　　　　　　"""类文档字符串"""
      实例方法(类内的函数methd)的定义
      类变量(class variable)定义
      类方法(@classmethod)定义
      静态方法(@staticmethod)定义

类的作用：
　　可以用类创建一个或多个此类的对象(实例)
  类内的变量和方法能被此类所创建的所有实例所共同拥有

说明：
  类名必须是标识符(与变量命名规则相同，建议首字母大写)
  类名实质上是变量，他绑定一个类实例
  类的定义最后面要加两个空行以告诉解释执行器，类的定义已经结束

示例：
　　class Dog:
      pass 


类　　　　　  对象　　　　  实例
class    object   instance


构造函数：
　　构造函数的调用方法表达式：
　　　　　类名([创建传参列表])
　　　　　[] 里的内容代表可省略
作用：
　　创建这个类的实例对象，并返回此实例对象的引用关系
示例：
class Dog:# 定义一个类
    pass
dog1=Dog()　# 用类来创建一个对象用dog1绑定
print(id(dog1)) # 打印dog1所在的内存地址
dog2=Dog()   # 创建第二个对象　用dog2绑定
print(id(dog2))
print(dog1 is dog2)　# 判断两只狗是不是同一条狗


实例说明：
　　实例有自己的作用域和名字空间，可以为该实例添加实例变量(也叫属性)
实例可以调用类的方法
实例可以访问类中的类变量


实例变量(属性 attribute)
  每个实例可以有自己的变量，称为实例变量(属性)


属性的使用方法:
　　实例.属性名

属性的赋值规则：
  (同变量规则相同)
１．首次为属性赋值则创建此属性
２．再次为属性赋值则改变属性的绑定关系

示例：
class Dog:
    pass
dog1=Dog()
dog1.kinds="京巴" # 为dog1绑定的实例添加kinds属性
dog1.color="白色"  # 添加属性
print(dog1.kinds,dog1.color)  # 访问属性
dog1.color="黄色"  #修改dog1.color 的绑定关系
print(dog1.color)


练习:
自己写一个student类，此类的对象有属性name,age,score,用来保存学生的姓名，年龄，成绩
１．写一个函数 input_student读入n个学生的信息，用对象来存储这些信息(不用字典)，并返回对象的列表
２．写一个函数output_student 打印这些学生信息(格式不限)
class student:
    pass


def input_student():
    l=[]
    while True:
        s = input("请输入名字:")
        if not s:
            break
        c = int(input("请输入年龄:"))
        b = int(input("请输入成绩:"))
        stu=student()
        stu.name = s
        stu.score = b
        stu.age = c
        l.append(stu)
    return l


def output_student(lst):
    for stu in lst:
        print("姓名:",stu.name,
             "年龄",stu.age,
             "成绩:",stu.score)
def main():
    a = input_student()
    output_student(a)


main()


删除属性：
　　del 语句

  语法：
  　　del 对象.属性名
示例：
class student():
    pass
stu=student()
stu.name='xiaozhang'  # 创建属性
print(stu.name)
del stu.name # 删除属性
print(stu.name)  # 属性错误，因为属性已经不存在


实例方法　method

语法：

 class 类名(继承列表)
  　　def 实例方法名(self, 参数1,参数2,...)
        语句块

作用：

　　用于描述一个对象的行为，让此类型的全部对象都拥有相同的行为

说明：
　实例方法的实质是函数，是定义在类内的函数
　实例方法的第一个参数代表调用这个方法的实例，一般命名为'self'

实例方法的调用语法：
　　实例.实例方法名(调用参数)
　　或
　　类名.实例方法名(实例，调用参数)

示例：
示意实例方法的定义方式和调用方法
class Dog:
    '''这是一个类，用于描述一个小动物的行为'''
    def eat(self,food):
        '''小狗有吃东西的行为'''
        print("小狗吃了:",food)
    def sleep(self,hour):
        print("小狗睡了",hour,"小时")

#实例.实例方法名(调用参数)
dog1=Dog()  # 创建一个实例对象
dog1.eat("骨头")  # 让狗吃东西
dog1.sleep(1)   # 让狗睡觉
dog2=Dog()  # 再创建一个实例对象
dog2.eat("包子")
dog2.sleep(2)

#类名.实例方法名(实例，调用参数) 一般不这样做
dog3=Dog()
Dog.eat(dog3,"狗粮")
Dog.sleep(dog3,3)



初始化方法：
　作用：
　　　对新创建的对象添加属性等必须的资源
　语法形式：
　　　class 类名：
　　　　　　 def __init__(self[,参数列表])
　　　　　　　　　　　语句块
　　　　　　　[]  代表其中内容可省略
说明：
　初始化方法必须为__init__不可改变
　初始化方法在构造函数创建实例后自动调用，且将实例自身通过第一个参数self传入__init__方法
　构造函数的实参将通过__init__方法的参数列表传到__init__方法中
　初始化方法内如果需要return 语句返回，则必须返回None

示例：
示意初始化方法的定义方式和调用过程
class Car:
    """小汽车类"""
    def __init__(self,c,b,m):
        self.color=c #颜色
        self.brand=b #品牌
        self.model=m #型号
        print("-----")
    def run(self,speed):
        print(self.color,'的',self.brand,
            self.model,'正在以',speed,
            '公里/小时的速度行驶')

a4=Car("红色",'奥迪','A4')
a4.run(199)


析构方法：
　　语法形式：
　　　　class 类名：
　　　　　　def __del__(self):
          语句块
  作用：
  　在对象被销毁之前被调用，主要负责清理对象所占的资源
  说明：
  　python建议尽可能少的在析构方法内做事情，因为销毁时间难以确定

示例：
class FileManage:
    """定义一个文件管理员"""
    def __init__(self,filename='a.txt'):
        self.file=open(filename,'w')
    def writeline(self,string):
        self.file.write(string)
        self.file.write('\n')
    def __del__(self):#在对象被销毁之前被自动调用
        """析构方法会在对象销毁前自动调用"""
        self.file.close()
        print("文件已关闭")
fm=FileManage()
fm.writeline("hello world")
fm.writeline("这是中文写的第二行")
del fm
while True:
    pass
print("程序结束")

预置的实例属性：
　　__dict__属性：
    用于绑定一个存储此实例自身的字典


  __class__属性：
  　　用于绑定创建此实例的类
  示例：
  class Dog:
      pass
  dog1=Dog()
  print(dog1.__dict__)
  dog1.color="白色"
  print(dog1.__dict__)
  print(dog1.__class__)

用于类的函数：
　isinstance(obj,class_or_tuple)　返回这个对象obj是否是某个对象，或者某些类中的一个类的对象，如果是则返回True,否则返回False
type(obj)返回对象的类
>>> class A:
...     pass
... 
>>> a=A()
>>>　isinstance(a,A)
True
>>>type(a) is A
True

对象：
　　属性(对象拥有的名词)　用实例变量存储
　　行为(对象拥有的动作)　用方法表示


练习：
定义一个类(人类)
有三个属性：
姓名:name  年龄: age 家庭住址: address(可省略)
有如下方法:
show_info(self) 用来显示人的信息
update_age(self) 用来让这个人的年龄增加一岁
def input_human():
  输入一些人的信息，姓名为空结束
def main():
docs=input_human()
for h in docs:
    h.show_info()# 列出所有人的信息
for h in docs:
    h.update_age()# 让所有的人都长一岁
for h in docs:
    h.show_info()再次列出所有人的信息
main()

class humen:
    def __init__(self,n,a,add="不详"):
        self.name=n
        self.age=a
        self.address=add
    def show_info(self):
        print("姓名:",self.name,
                "年龄:",self.age,
                "家庭住址:",self.address)
    def update_age(self):
        self.age+=1
def input_human():
    l=[]
    while True:
        na=input("请输入姓名:")
        if not na:
            break
        aj=int(input("请输入年龄:"))
        dp=input("请输入家庭住址:")
        l.append(humen(na,aj,dp))
    return l
def main():
    docs=input_human()
    for h in docs:
        h.show_info()
    for h in docs:
        h.update_age()
    for h in docs:
        h.show_info()
main()




day 20

类变量：
　　类变量是类的属性，此属性属于类，不属于此类创建的实例
说明：
　 类变量，可以通过该类直接访问
  类变量可以通过该类的实例直接访问
  类变量可以通过此类的对象的'__class__'属性间接访问
示例：
class human:
    toutal_count=0 #类变量，用于记录对象的个数

print(human.toutal_count)
h1=human()
print(h1.toutal_count)   # 0
human.toutal_count=1 # 修改类变量
h1.toutal_count=2 #添加了自己的实例属性toutal_count
h1.__class__total_count=3 # 间接修改类变量


示例：
#此示例示意类变量的用法和使用方法
class human:
    total_count=0 #类变量，用于记录对象的个数
    def __init__(self,name):
        self.name=name
        self.__class__.total_count+=1#　人数加一
        print(name,"对象创建")
    def __del__(self):
        self.__class__.total_count-=1#　总人数减一

print("当前对象的个数是",human.total_count)
h1=human("张飞")
h2=human("赵云")
print("当前对象个数是:",human.total_count)   # 2
del h2 # 或 h2=None
print("当前对象个数是:",human.total_count)   # 1

类的__slots__属性
作用：
　　限定一个类的创建的实例只能有固定的属性(实例属性)
说明：
　　　__slots__属性是一个列表，列表的值是字符串
　　　含有__slots__属性的类所创建的对象没有__dict__字典

示例：
class student:
    # 限定此类创建的对象只能有name和age两个属性
    __slots__=["name","age"]
    def __init__(self,n,a):
        self.name=n
        self.age=a
s1=student("小张",20)
s1.Age=21 # 此时是错写为Age，添加__slots__属性后会报错
print(s1.__dict__)　# 出错，因为没有__dict__字典



类方法　@classmethod
  类方法是操作类的方法，类方法属与类，不属于该类创建的对象

说明：

　　类方法需要是使用@classmethod装饰定义
　　类方法的第一参数用来绑定类，约定写为cls
　　类和对象实例都可以调用类方法
　　类方法不能访问此类创建的对象的属性

示例：
class A:
    v=0 # 类变量
    @classmethod
    def get_v(cls): #此方法不是实例方法，是类方法
    　　　　return cls.v

详细示例：

class A:

    v=0 # 类变量

    @classmethod
    def get_v(cls): #从方法不是实例方法，是类方法
        return cls.v
    @classmethod
    def set_v(cls,value):
        cls.v=value


print(A.get_v()) # 0
A.v=1
print(A.get_v()) #1
A.set_v(100)
print(A.get_v()) # 100
a=A() #创建一个实例
a.set_v(200)  # 此时cls=a.__class__(属性)
print(A.get_v())# 200



静态方法 @staticmethod
  静态方法是定义在类内部的函数，此时函数作用域是类的内部
  说明：
  　　静态方法需要使用@staitc装饰器定义
  　　静态方法与普通函数的定义不同，不需要传入self和cls
  静态方法只能凭借该类和实例来调用
  静态方法不能访问类变量和实例变量
  示例：
  class A:
      @staticmethod
      def myadd(a,b):
          return a+b
print(A.myadd(100,200))
a=A()
print(A.myadd(300,400))



练习
　　修改之前的humen类　让此类能够记录此类生成的对象的个数，用创建一个类方法get_humen_count来获取'人对象'的个数
class humen:
    total_count=0
    def __init__(self,n,a,add):
        self.name=n
        self.age=a
        self.address=add
        self.__class__.total_count+=1
    def __del__(self):
        self.__class__.total_count-=1
    @classmethod
    def get_humen_count(cls):
        return cls.total_count # 返回总人数
    def show_info(self):
        print("姓名:",self.name,
                "年龄:",self.age,
                "家庭住址:",self.address)
    def update_age(self):
        self.age+=1
def input_human():
    l=[]
    while True:
        na=input("请输入姓名:")
        if not na:
            break
        aj=int(input("请输入年龄:"))
        dp=input("请输入家庭住址:")
        stu=humen(na,aj,dp)
        l.append(stu)
    return l
def main():
    docs=input_human()
    print("当前的总人数:",humen.get_humen_count())
    # docs+=input_human()
    # print("当前的总人数:",humen.get_humen_count())
    for h in docs:
        h.show_info()
    for h in docs:
        h.update_age()
    for h in docs:
        h.show_info()
main()



继承 inheritance 和 派生 derived
　　什么是继承 / 派生
　　　继承是从已有类中派生出新类，新类具有原类的数据属性和行为，并能扩展新的能力
   派生就是从一个已有的类衍生出新类，在新的类上添加新的属性和行为

作用：
１．用继承派生机制，可以将一些共有功能加在基类中，实现代码的共享
２．在不改变超类的代码的基础上，改变原有的功能

名词：
基类(base class) / 超类(super class) / 父类(father class)
派生类(derived class) / 子类(child class)

单继承：
　　语法：
　　　　class 类名(超类名):
        语句块
示例：
#此示例示意单继承的语法及使用方法
class human:  # 人
    def say(self,what):   # 说话的行为
        print("说:",what)
    def walk(self,distance):   # 走路的行为
        print("走了",distance,"公里")

class student(human):
    def study(self,subject):
        print("正在学习",subject)

class teacher(student):
    def teach(self,that):
        print("老师在教:",that)

h1=human()
h1.say("今天天气不错!")
h1.walk(5)
print("------------")
s1=student()
s1.say("今天晚饭吃什么")
s1.walk(3)
s1.study("python")
print("-----------")
t1=teacher()
t1.say("今天下班早点回家")
t1.walk(1)
t1.study("魔方")
t1.teach("面向对象")

练习：
list类里只有append向末尾添加一个元素的方法，但没有向列表添加元素的方法，试想能否为列表在不改变原有功能的基础上添加一个insert_head(n),在列表的头部添加

class mylist(list):
    def insert_head(self,element):
        self.insert(0,element)
myl=mylist(range(3,6))
print(myl)
myl.insert_head(2)
print(myl)

继承属性：
　　任何类都直接或间接继承自object类
　　object类是一切类的超类

类内的__base__属性
　　此属性用来记录此类的基类

示例：
详见>>>help(__builtins__)
>>>class human:
...    pass
...
>>>class student(human):
...    pass
>>>class teacher(student):
...    pass
...
>>>teacher.__base__
# <class '__main__.student>


覆盖： override
什么是覆盖：
　　覆盖是指在有继承派生关系的类中，子类中实现了与基类(超类)同名的方法，在子类实例调用方法时，实际调用的是子类的覆盖版本，这种现象叫覆盖
示例：
class A:
    def work(self):
        print("A类的work方法被调用")
class B(A):
    pass
b=B()
b.work()  # 调用A

class A:
    def work(self):
        print("A类的work方法被调用")
class B(A):
    def work(self):
        print("B类的work方法被调用")
b=B()
b.work()  # 调用B　　，　此时子类已经覆盖父类的方法
A.work(b)  #  A类的work方法被调用
问题：
当覆盖发生时，子类对象能否调用父类中的方法?

super函数
　　super(type,obj)
  返回绑定超类的实例(要求obj必须为type类型的实例)
  super() 返回绑定超类的实例，等同于super(__class__,实例的第一个参数)，且必须在方法内调用

作用：
　　返回超类的实例，用超类实例来调用其自身的方法

示例：
class A:
    def work(self):
        print("A类的work方法被调用")
class B(A):
    def work(self):
        print("B类的work方法被调用")
    def doworks(self):
        self.work()  　# 调用谁? #调用B类的方法
        super(B,self.work())　#调用超类的方法
        super().work()　　#一样会调用超类方法
        super(__class__,self).work()　#一般不用这种方法
b=B()
b.work()  # 调用B　　，　此时子类已经覆盖父类的方法
print("-----------------------------")
super(B,b).work()
b.doworks()


显示调用基类的初始化方法：
　
说明：
当子类实现了__init__方法后，父类的__init__方法将会被覆盖，及不再会主动调用父类的__init__方法，会引起父类的属性得不到初始化，此时需要显示父类的初始化方法

示例：
class human:
    def __init__(self,n,a):
        self.name=n
        self.age=a
        print("human类的__init被调用")
    
    def show_info(self):
        print("姓名:",self.name)
        print("年龄:",self.age)
class student(human):
    def __init__(self,n,a,s=0):
        super().__init__(n,a)#显示调用基类的初始化方法
        self.score=s
        print("student类的__init__被调用")
    def show_info(self):
        super().show_info()
        print("成绩",self.score)

s1=student("张学友",40)
s1.show_info()

练习：
１．
看懂学生管理系统划分模块的依据
添加保存文件和读取文件代码
把字典改为对象存储数据(最好把学生对象的实例对象都封装在类里，让类外的函数不要操作这些实例变量)
２．练习：
写一个Biycycle(自行车)类，有run(骑行)方法，调用时显示骑行里程km
class Bycycle:
    def run(self,km):
        print("自行车骑行了:",km,"公里")
再写一个电动车类EBicycle继承自biycycle,添加电池电量valume属性，同时有两个方法：
fill_charge(vol)  用来充电vol为电量(度)
run(km)方法用于骑行，每骑行10km消耗电量1度,当电量消耗尽时调用biycycle的run方法骑行
并显示骑行结果
主程序:
b=EBicycle(5)# 创建一个电动自行车，默认电量5度
b.run(10)#骑行10km
b.run(100)#骑行100km
b.fill_charge(6)#充电6度
b.run(70)  #又骑行70km

class Biycycle:
    def run(self,km):
        print("自行车骑行了:",km,"公里")
class EBicycle(Biycycle):
    def __init__(self,vol):
        self.valume=vol
    def fill_charge(self,vol):
        print("电动车充电:",vol,"度")
        self.valume+=vol
    def run(self,km):
        e_km=min(km,self.valume*10)
        self.valume-=e_km/10
        if e_km>0:
            print("电动车骑行:",e_km,"公里")
        if km>e_km:
            super().run(km-e_km)

b=EBicycle(5)
b.run(10)
b.run(100)
b.fill_charge(6)
b.run(70)
b.run(10)



day 21


issubcalss 函数 
　　issubclass(cls,class _or_ tuple)
  判断一个类是否继承自其它的类，如果此类cls是class或tuple中的一个派生子类，咋返回True否则返回False

示例：
class A:
    pass
class B(A):
    pass
class C(B):
    pass
class D(B):
    pass
issubclass(B,A)  # True
issubclass(C,B)  # True
issubclass(D,C)  # False
issubclass(C,(int,str))  # False
                                                                                                                                                                                      

封装 enclosure
  封装是指隐藏类的实现细节，让使用者不关心这些细节
  封装的目的是让使用者通过尽可能少的使用实例变量名(属性)操作对象

私有属性和方法
　　python　类中以双下划线("__")开头，不以双下划线结尾的标识符为私有成员　　　　　　　　　　　　　　　　　　　　　　　　　
　　私有成员只能被方法调用，不能在子类或其他地方使用
私有成员有两种：
　　私有属性
　　私有方法
class A:
    def __init__(self):
        self.__p1=100 #创建私有属性
    def __m1(self):
        print("A类的私有方法被调用!")
    def test(self):
        print(self.__p1) # 可以访问
        self.__m1()  # 可以访问
a=A()
print(a.__p1)  # 出错，不可以访问
a.test()  # 100　　用方法来操作私有属性和私有方法
a.__m1() #　出错，在类外部不能调用类的私有方法


多态　　polymorphic
  字面意思：　多种状态
  多态是指在有继承/派生关系的类中，调用基类对象的方法，实际能调用子类的覆盖方法的现象叫多态
什么是多态？
  概念：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说:就是用基类的引用指向子类的对象

多态说明：
　　多态调用方法与对象相关，不与类相关
　　python 的全部对象只有"运行时状态(动态)",没有"c++/Jave"里的"编译时状态(静态)"

多态示例:
class Shape:
    def draw(self):
        pass
class Point(Shape):
    def draw(self):
        print("正在画一个点")
class Circle(Point):
    def draw(self):
        print("正在画一个圆")
def my_draw(s):
    s.draw() #　调用哪的方法 在运行时动态决定调用的方法
s1=Circle()
s2=Point()
my_draw(s1)
my_draw(s2)


面向对象编程语言的特征：
　封装
　继承
　多态
面向对象的语言: C++ /Java/Python/Swift/C#



多继承：
　对继承是指一个子类继承自两个或两个以上的基类

语法：
class 类名(超类名1,超类名2,...):
    pass

示例：
class Car:
    def run(self,speed):
        print("汽车以",speed,"km/h的速度行驶")
class Plane:
    def fly(self,height):
        print("飞机以海拔",height,"米的高度飞行")

class Planecar(Car,Plane):
    """飞机汽车类，是继承　自 Car和Plane"""
    pass

p1=Planecar()
p1.fly(2000)
p1.run(299)



多继承的问题(缺陷)
　　标识符(名字空间)冲突的问题
　　　　要谨慎使用多继承


示例：
class A:
    def m(self):
        print("A.m()被调用")
#小李写了一个类B
class B:
    def m(self):
        print("B.m()被调用")
#小王感觉小张和小李写的两个类自己可以用
class AB(A,B):
    pass
ab=AB()
ab.m() # 请问调用谁


多继承的 MRO (Method Resolution Order)问题
　　　MRO 方法搜索顺序问题
　　　python2 中用的是深度优先(按顺序找父类的深层父类)
　　　python3 中用的是广度优先(就近原则，先找父类的同级，再接着往下搜寻)　　　　　　　　　　　　　　　　　　　　　　　

函数重写　overwrite

什么是函数重写
　　在自定义的类中，通过添加特定的方法，让自定义的类生成对象(实例)　能像內建对象一样进行内建函数操作


>>> class A:
...     def __len__(self):
...         return 100
... 
>>> a=A()
>>> len(a)
100


对象转字符串函数重写
　　repr(obj) 返回一个能代表此对象的字符串,通常:
      eval(repr(obj))==obj
  str(obj)  通过给定的对象返回一个字符串(这个字符串通常是给人阅读的)
  　　换句话说：
  　　　　repr(obj) 返回的字符串是给python 用的
  　　　　str(obj) 返回的字符串是给人看的
重写方法
repr(obj)函数的重写方法　def __repr__(self)
str(obj) 函数的重写方法  def __str__(self)
当对象没有__str__方法时，则返回__repr__(self)的值

示例：
class MyNumber:
    def __init__(self,value):
        self.data=value
    def __str__(self):
        print("__str__方法被调用")
        return "数字: %d" % self.data

n1=MyNumber(100)
print(str(n1)) # 此句其实等同于print(n1)
print(n1)
print(repr(n1))#他会调用n1.__repr__()方法

当对象没有__str__方法时，则返回__repr__(self)的值示例：
class MyNumber:
    def __init__(self,value):
        self.data=value
    def __repr__(self):
        """此方法供repr(obj)函数调用!"""
        return "MyNumber(%d)" % self.data
n1=MyNumber(100)
print(str(n1)) 
print(n1)
print(repr(n1))
##################
MyNumber(100)
MyNumber(100)
MyNumber(100)


内建函数的重写：
obj.__abs__() 方法对应　abs(obj)
obj.__len__() 方法对应　len(obj)
obj.__reversed__() 方法对应　reversed(obj)
obj.__round__() 方法对应　round(obj)

示例：
此示例示意abs(obj)函数的重写方法 obj.__abs__() 方法的使用


class MyInteger:
    def __init__(self,value):
        self.data=value
    def __repr__(self):
        return 'MyInteger(%d)' % self.data
    def __abs__(self):
        if self.data<0:
            return MyInteger(-self.data)#创建一个新的对象并返回值

        return MyInteger(self.data)
    def __len__(self):
        """len(x)函数规定只能返回整数值，因此此方法不能放回字符串等其它类型的值"""
        return 100

I1=MyInteger(-10)
print(I1)  # <--此处等同于print(str(I1))
I2=abs(I1)  # I2=MyInteger(10)
print(I2)  # MyInteger(10)
print(len(I1))



数值转换函数重写
　　obj.__complex__()  对应　complex(obj)
　　obj.__int__()      对应　int(obj)
　　obj.__float__()    对应　float(obj)
　　obj.__bool__()     对应　bool(obj)


此示例示意数值类型转换函数重写
class MyNumber:
    """此类是自定义的类，用于表示自定义数字的类型"""
    def __init__(self,v):
        self.data=v
    def __repr__(self):
        return 'MyNumber(%s)' % self.data
    def __int__(self):
        return int(self.data)
    def __float__(self):
        return float(self.data)

n1=MyNumber("100")
print('n1=',n1)
print(int(n1)) # 100
print(float(n1))# 需要实现__float__(self) 方法　　



布尔测试函数的重写
格式：
　　def __bool__(self):
     ...
作用：
１．用于bool(obj)函数取值
２．用于if语句真值表达式
３．用于while 语句真值表达式中
说明：
　　布尔测试式方法的查找顺序是__bool__方法，其次是__len__方法，如果没有以上方法则返回True

示例：
#此示例示意　bool真值测试函数的重写
class MyList:
    """定义一个容器，用于存储任意类型的数据
    其内部的存储方式用list实现"""
    def __init__(self,iterable):
        self.data=[x for x in iterable]
    def __repr__(self):
        return 'MyList(%s)' % self.data
    def __bool__(self):
        """此方法用于bool(obj)函数取值，优先取值此函数
        的返回值，此方法用于定义bool(obj)的取值规则"""
        # 规则，所有元素的和为0，咋返回False否则返回True
        return sum(self.data)!=0

myl=MyList([1,-2,5,-4])
print(myl)
print('bool(myl)=',bool(myl))
if myl:
    print("myl 的布尔值为True")
else:
    print("myl 的布尔值为False")

示例：
布尔测试式方法的查找顺序是__bool__方法，其次是__len__方法，如果没有以上方法则返回True　　的示例：
此示例示意　bool真值测试函数的重写
class MyList:
    """定义一个容器，用于存储任意类型的数据
    其内部的存储方式用list实现"""
    def __init__(self,iterable):
        self.data=[x for x in iterable]
    def __repr__(self):
        return 'MyList(%s)' % self.data
    def __len__(self):
        print("__len__方法被调用!")
        return len(self.data)   #　返回列表长度
        
myl=MyList([1,-2,5,-4])
print(myl)
print('bool(myl)=',bool(myl))
if myl:
    print("myl 的布尔值为True")
else:
    print("myl 的布尔值为False")



迭代器(高级)
　　什么是迭代器
　　　　可以通过　next(obj)函数取值的对象，就是迭代器

迭代器协议：
　　迭代器协议是指对象能够使用next函数获取下一项数据，在没有下一项数据时触发一个StopIteration异常来终止迭代的约定
迭代器协议的实现方法：
　　在类内需要定义__next__(self)方法来实现迭代器协议
语法形式：
class MyIterator:
    def __next__(self):
        迭代器协议
        return 数据


什么是可迭代对象：
　　是指能用iter(obj)函数返回迭代器的对象(实例)
　　可迭代对象的内部要定义__iter__(self)方法来返回迭代器对象



练习：
１．完善学生管理系统读取学生信息的功能
２．看懂类的封装的用意，及功能的划分(如：　save_to_file(self)方法等)

３．写一个实现迭代器协议的类Primes
让此类可以生成从b开始的n个素数
class Primes:
    def __init__(self,b,n):
        ....
    ....
for x in Primes(10,20):
    print(x) # 11 13 17 19



４．扩展学生信息管理程序，试想能否在不改变原Student类的基础上，为每个学生添加一个家庭住址的信息
(提示，用继承/派生机制创建一个新的类)
５．11)添加修改家庭住址的功能



day 22

属性管理函数：


 
getattr(obj, name[, default]) 	从一个对象得到对象的属性；getattr(x, 'y') 等同于x.y; 当属性不存在时,如果给出default参数,则返回default,如果没有给出default 则产生一个AttributeError错误

hasattr(obj, name) 	用给定的name返回对象obj是否有此属性,此种做法可以避免在getattr(obj, name)时引发错误

setattr(obj, name, value) 	给对象obj的名为name的属性设置相应的值value, setattr(x, 'y', v) 等同于 x.y = v

delattr(obj, name) 	删除对象obj中的name属性, delattr(x, 'y') 等同于 del x.y



异常(高级)

with语句
 语法：
   with 表达式1 [as 变量名1], 表达式2 [as 变量名2],...
 作用：
   用于对资源访问的场合，确保使用过程中不管是否发生异常，都会执行必要"清理"操作，并释放资源
 如：
   文件打开后自动关闭，线程中自动获取和释放(线程后面会讲)
 说明：
  with 语句与try-finally相似，并不会必变异常状态
  as 子句用于绑定表达式创建的对象

示例：
def read_file():
    try:
        with open("ssss.py") as f
            while True:
                s=f.readline()
                if not s:
                    break
                int(input("请输入任意数自己打印下一行:"))
                print(s)
    except IOError:
        print("程序异常已经捕获!")
    except ValueError:
        print("程序已转为正常状态")

read_file()
print("程序结束")


>>>with open('ssss.py')  as f
...    f.reaad()




环境管理器：
  类内有__enter__ 和 __exit__ 方法的类被称为环境管理器
  能够用with进行管理的对象必须是环境管理器
  __enter__将在进入with语句时被调用，并返回由as变量管理的对象
  __exit__将在离开with语句时被调用，且可以来判断离开with语句时是否出现异常并做出相应处理

示例：

练习：实现文件的复制(建议使用二进制方式操作)
python3 mycp.py
请输入原文件: /etc/passwd
请输入目标文件: ./mypass.txt
文件复制成功 或 文件复制失败

def mycp(src_file,dst_file):
    """
    src_file 原文件名
    dst_file 目标文件名
    """
    try:
        with open(src_file,'rb') as fr,\
            open(dst_file,'wb') as fw:
                # 如果文件太大则分次搬运
                while True:
                    b=fr.read(4096)# 文件太大时，控制字节串字符
                    if not b:# 如果字节串为空，停止复制
                        break
                    fw.write(b)      
    except:
        return False
    return True

def main():
    src=input("请输入原文件名:")
    dst=input("请输入目标文件名:")
    if mycp(src,dst):
        print("复制文件成功")
    else:
        print("复制文件失败")

main()



运算符重载：
  什么是运算符重载：
    让自定义的类生成的对象(实例)能够使用运算符进行操作
  作用：
    让实例像数学表达式一样进行操作
    让程序简洁易读
  说明：
    运算符重载方法的参数已经有固定的含义，不建议改变原有的含义

算术运算符：
    方法             运算符
  __add__            加法 +
  __sub__            减法 -
  __mul__            乘法 *
  __truediv__        除法 /
  __floordiv__       地板除 //
  __mod__            取模(求余) %
  __pow__            幂 **

>>>a=[1,2,3]
>>>b=[4,5,6]
>>> a.__add__(b)
[1,2,3,4,5,6]


二元运算符重载方法格式：
  def __xxx__(self,other):
      ....
示例：
class MyNumber:
    def __init__(self,v):
        self.data=v
    def __repr__(self):
        return "MyNuber(%d)" % self.data
    def __add__(self,other):
        print("__add__方法被调用")
        obj=MyNumber(self.data+other.data)
        return obj
    def __sub__(self,other):
        print("__sub__方法被调用")
        obj=MyNumber(self.data-other.data)
        return obj

n1=MyNumber(100)
n2=MyNumber(200)
n3=n1.__add__(n2) # 等同于 n3=n1+n2
print(n3)
n4=n2-n1
print(n4)


练习：
  实现两个自定义表的相加
  class MyList:
      def __init__(self,iterable):
          self.data=[x for in iterable]
          ...类内以下部分自己实现
  l1=MyList([1,2,3])
  l2=MyList(range(4,7))
  l3=l1+l2
  print("l3",l3)# MyList([1,2,3,4,5,6])
  l4=l1*2 # 实现乘法运算
  print("l4=",l4)


class MyList:
    def __init__(self,iterable):
        self.data=[x for x in iterable]
    def __repr__(self):
        return "MyList(%s)" % self.data
    def __add__(self,other):
        obj=MyList(self.data+other.data)
        return obj
    def __mul__(self,other):
        obj=MyList(self.data*other)
        return obj      
l1=MyList([1,2,3])
l2=MyList(range(4,7))
l3=l1+l2
print("l3=",l3)# MyList([1,2,3,4,5,6])
l4=l1*2 # 实现乘法运算
print("l4=",l4)



反向算术运算符：
    方法             运算符
  __radd__            加法 +
  __rsub__            减法 -
  __rmul__            乘法 *
  __rtruediv__        除法 /
  __rfloordiv__       地板除 //
  __rmod__            取模(求余) %
  __rpow__            幂 **
示例：
class MyList:
    def __init__(self,iterable):
        self.data=[x for x in iterable]
    def __repr__(self):
        return "MyList(%s)" % self.data
    def __mul__(self,other):
        obj=MyList(self.data*other)
        return obj    
    def __rmul__(self,lh):
        print("__rmul__方法被调用,lh=",lh)
        obj=MyList(self.data*lh)
        return obj      
l1=MyList([1,2,3])
l2=MyList(range(4,7))
l4=l1*2 # 实现乘法运算
print("l4=",l4)
l5=2*l1
print("l5=",l5)



复合赋值运算符重载：
    方法             运算符
  __iadd__            加法 +=
  __isub__            减法 -=
  __imul__            乘法 *=
  __itruediv__        除法 /=
  __ifloordiv__       地板除 //=
  __imod__            取模(求余) %=
  __ipow__            幂 **=

示例：
#此示例示意复合赋值算术运算符的重载
class MyList:
    def __init__(self,iterable):
        self.data=[x for x in iterable]
    def __repr__(self):
        return "MyList(%s)" % self.data
    def __add__(self,rhs):
        print("__add__方法被调用")
        return MyList(self.data+rhs.data)
    def __iadd__(self,rhs):
        print("__iadd__方法被调用")
        self.data.extend(rhs.data)
        return self

l1=MyList([1,2,3])
l2=MyList(range(4,7))
l1+=l2  # 相当于 l1=l1+l2  优先用iadd方法否则用add方法
print("l1=",l1)


#算法一
a=[100]
def test(x):
    x=x+x
    print(x)
test(a)
print(a)
#算法二
a=[100]
def test(x):
    x+=x
    print(x)
test(a)
print(a)



比较运算符的重载：
__lt__   < 小于
__le__   <= 小于等于
__gt__   > 大于
__ge__   >= 大于等于
__eq__   == 等于
__ne__   != 不等于

注： 比较运算符通常返回True 或 False

位运算符重载:
__inert__     ~   取反(一元运算符)
__and__       &   位于(交集)
__or__        |   位或(并集)
__xor__       ^   位异或(对称补集)
__lshift__   <<   左移
__rshift__   >>   右移
反向位运算符重载:
__rinert__     ~   取反(一元运算符)
__rand__       &   位于(交集)
__ror__        |   位或(并集)
__rxor__       ^   位异或(对称补集)
__rlshift__    <<  左移
__rrshift__    >>  右移
复合赋值运算符重载
__iand__       &=  位于(交集)
__ior__        |=  位或(并集)
__ixor__       ^=  位异或(对称补集)
__ilshift__   <<=  左移
__irshift__   >>=  右移

一元运算符的重载：

  __neg__     - 负号
  __pos__     + 正号
  __invert__  ~ 按位取反

格式：
  def __xxx__(self):
      ....
示例：
class MyList:
    def __init__(self,iterable):
        self.data=[x for x in iterable]
    def __repr__(self):
        return "MyList(%s)" % self.data
    def __neg__(self):
        print("__neg__方法被调用")
        l=(-x for x in self.data)
        return MyList(l)


l1=MyList([1,-2,3,-4,5])
print("l1=",l1)
l2 = -l1
print("l2=",l2)


in / not in 运算符的重载
格式：
  def __contains__(self,e)  # e 代表元素
    ...
说明：
   not in 相当于 in 取反, 所以只需要重载 in 即可
示例：

class MyList:
    def __init__(self,iterable):
        self.data=[x for x in iterable]
    def __repr__(self):
        return "MyList(%s)" % self.data
    def __contains__(self,e):  # e 代表测试元素
        print("__contains__方法被调用")
        for x in self.data:
            if e==x:# 如果相同，则说明e在列表中
                return True
        return False 

l1=MyList([1,-2,3,-4,5])
if 2 in l1:  # 需要重载 __contains__方法
    print("2在l1中")
else:
    print("2不在l1中")


索引和切片运算符的重载：

 重载方法：
  __getitem__(self,i)  用于索引/切片取值
  __setitem__(self,i,v)  用于索引/切片赋值
  __delitem__(self,i)  用于del语句删除索引操作
 作用：
   让自定义的类型的对象能够支持索引和切片操作
 示例

class MyList:
    def __init__(self,iterable):
        self.data=[x for x in iterable]
    def __repr__(self):
        return "MyList(%s)" % self.data
    def __getitem__(self,i):
        print("__getitem__被调用",i)
        return self.data[i]
    def __setitem__(self,i,v):
        print("__setitem__被调用")
        self.data[i]=v
    

l1=MyList([1,-2,3,-4,5])
print(l1[2])
l1[1]=2
print(l1)

class MyList:
    def __init__(self,iterable):
        self.data=[x for x in iterable]
    def __repr__(self):
        return "MyList(%s)" % self.data
    def __getitem__(self,i):
        if type(i) is slice:
            print("正在进行切片操作")
        elif type(i) is int:
            print("正在进行索引操作")
        print("__getitem__被调用",i)
        return self.data[i]
    def __setitem__(self,i,v):
        print("__setitem__被调用")
        self.data[i]=v
    

l1=MyList([1,-2,3,-4,5])
print(l1[::2])



PEP8编码规范
代码编排

   1使用4空格缩进，不使用Tab,更不允许用Tab和空格混合缩进
   2每行最大长度最大79字节，超过部分使用反斜杠折行
   3类和全局函数定义间隔两个空行,类内方法定义间隔一个空行.其它地方可以不加空行。

文档编排

   1其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。
   2不要在一句import中导入多个模块，比如不推荐import os, sys。
   3尽可能用import XX 而不采用from XX import YY引用库,因为可能出现名字冲突。

空格的使用

   1各种右括号前不用加空格
   2逗号、冒号、分号前不要加空格。
   3函数的左括号前不要加空格。如func(1)。
   4序列的左括号前不要加空格。如list[2]。
   5操作符左右各加一个空格，不要为了对齐增加空格。
   6函数默认参数使用的赋值符左右省略空格。
   7不要将多条语句写在同一行，尽管使用‘;’允许。
   8if/for/while语句中，即使执行语句只有一句，也必须另起一行

原则：避免不必要的空格


练习：
  实现有序集合类 OreerSet(), 能实现两个集合的交集 &, 并集 |,
  补集 -, 对称补集 ^, ==， !=, 等操作(写集合相同)
  要求：
    集合内部用list存储
    class OrderSet:
        def __init__(self,iterable):
            self.data = [x for x in iterable]
            ...
  测试用例：
    s1=OrderSet([1,2,3,4])
    s2=OrderSet([3,4,5])
    print(s1 & s2)  # OrderSet([3,4])
    print(s1 | s2)  # OrderSet([1,2,3,4,5])
    print(s1 ^ s2)  # OrderSet([1,2,5])
    if OrderSet([1,2,3]) != OrderSet([1,2,3,4]):
        print("不想同")
    其他自己测试 